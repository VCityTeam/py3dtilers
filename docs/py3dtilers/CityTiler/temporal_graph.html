<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>py3dtilers.CityTiler.temporal_graph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>py3dtilers.CityTiler.temporal_graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import sys
from enum import Enum, unique
from pprint import pprint

from .temporal_utils import debug_msg, debug_msg_ne, debug_mode


class Node(object):
    @unique
    class Status(Enum):
        &#34;&#34;&#34;
        Historical status of the node (mainly used on documentation/debug
        purposes) indicating the nature of the node in its relationship
        with past and future nodes
        &#34;&#34;&#34;
        unknown = 1
        # Appears isolated at a single time stamp (neither ancestors nor
        # descendants)
        hapax = 2
        # Beginning of a lineage of nodes (no ancestors)
        start = 3
        # Termination of a lineage of nodes (no descendants)
        end = 4
        # Historical link/connection between the past nodes and future nodes
        # (has both ancestors and descendants)
        link = 5

    def __init__(self, **kwargs):
        # Attributes that will be dynamically added by the Json parsing
        # An integer used as Node identifier (local to a single Graph file)
        self.id = None
        # A string used as (global) Node identifier i.e. valid across a
        # set of Graph files
        self.globalid = None
        self.__dict__ = kwargs

        # When blending various graphs (respectively loaded from different
        # graph files), the nodes shared among such graphs (as designated
        # with their globalid) need to be reconciled. For some nodes (
        # (e.g. for nodes that are loaded when a previous node with
        # the same globalid already existed) the self.id (relative to a
        # file) will thus be lost. In order to help traceability (read
        # debugging) of the nodes, we keep the original file identifiers
        # in the following attribute:
        self.file_ids = &#39;&#39;

        self.start_date = None
        self.end_date = None

        # Design note: we had the choice to either store the ancestor nodes
        # or to store the &#34;ancestor edges&#34; (that is edges that have this
        # node as target). Both choices have their respective drawbacks.
        # When storing the nodes and we need the information attached to
        # the edges we need to retrieve those edges (and the cost of retrieving
        # an edge out of its adjacent vertices is not constant in graph size).
        # And when storing the edges, retrieving the ancestors requires a
        # (constant time) walk on those edges.
        # Note that storing both is always risky because we must keep them
        # &#34;aligned&#34; (in sync).
        # We chose to store edges to keep the computation complexity constant.
        # The list of edges that have this node as target:
        self.ancestor_edges = list()

        # A list of edges which have this node a source. The targets of those
        # edges are thus nodes that come after in time which make them
        # descendants:
        self.descendant_edges = list()

        self.status = Node.Status.unknown
        self.set_hapax(self.get_time_stamp())

    def __str__(self):
        ret_str = f&#39;Node: {self.globalid} (id: {self.id})\n&#39;
        ret_str += f&#39;  Starting date: {self.start_date} \n&#39;
        ret_str += f&#39;  Ending date: {self.end_date} \n&#39;
        ret_str += f&#39;  Status: {self.status} \n&#39;
        if self.ancestor_edges:
            ret_str += &#39;  Ancestors: &#39;
            for ancestor in self.get_ancestors():
                ret_str += ancestor.globalid + &#39;, &#39;
            ret_str += &#39;\n&#39;
        if self.descendant_edges:
            ret_str += &#39;  Descendants: &#39;
            for descendant in self.get_descendants():
                ret_str += descendant.globalid + &#39;, &#39;
            ret_str += &#39;\n&#39;
        if self.file_ids != &#39;&#39;:
            ret_str += f&#39;  file_ids: {self.file_ids}\n&#39;
        return ret_str

    def is_unknown(self):
        if self.status == Node.Status.unknown:
            return True
        return False

    def is_hapax(self):
        if self.status == Node.Status.hapax:
            return True
        return False

    def is_start(self):
        if self.status == Node.Status.start:
            return True
        return False

    def is_end(self):
        if self.status == Node.Status.end:
            return True
        return False

    def is_link(self):
        if self.status == Node.Status.link:
            return True
        return False

    def assert_status_coherence(self):
        ancestors = self.get_ancestors()
        descendants = self.get_descendants()
        if not ancestors and not descendants:
            if self.is_unknown():
                # No information and nothing to assert
                return
            if self.is_hapax():
                # A hapax indeed has not ancestors nor descendants
                return
            else:
                print(&#34;Only a hapax has neither ancestors nor descendants.&#34;)
                sys.exit(1)
        if ancestors and not descendants:
            if self.is_unknown():
                print(&#34;Should have been an end prior to having ancestors.&#34;)
                sys.exit(1)
            return
        if not ancestors and descendants:
            if self.is_unknown():
                print(&#34;Should have been a start prior to having descendants.&#34;)
                sys.exit(1)
            return
        # The Node has both ancestors and descendants:
        if self.is_unknown():
            print(&#34;Should have been a hapax, a start or end prior to having&#34;)
            print(&#34;both ancestors and descendants.&#34;)
            sys.exit(1)
        if not self.is_link():
            print(&#34;This node has both ancestors and descendants but is not&#34;)
            print(&#34;a link but a: &#34;, self.status)
            sys.exit(1)

    def are_all_ancestor_edges_of_type(self, edge_type):
        &#34;&#34;&#34;
        :return: True when they are at least two ancestor edges and all
                 ancestor edges are of the provided parameter (edge) type.
                 False otherwise.
        &#34;&#34;&#34;
        ancestor_edges = self.get_ancestor_edges()
        if len(ancestor_edges) &lt; 2:
            # We need at least two edges for them to be the same
            return False
        for edge in ancestor_edges:
            if not edge.is_of_type(edge_type):
                return False
        return True

    def are_all_descendant_edges_of_type(self, edge_type):
        &#34;&#34;&#34;
        :return: True when they are at least two descendant edges and all
                 descendant edges are subdivision edges. False otherwise.
        &#34;&#34;&#34;
        descendant_edges = self.get_descendant_edges()
        if len(descendant_edges) &lt; 2:
            # We need at least two edges for them to be the same
            return False
        for edge in descendant_edges:
            if not edge.is_of_type(edge_type):
                return False
        return True

    def do_all_ancestor_nodes_share_same_date(self):
        &#34;&#34;&#34;
        :return: True when they are at least two ancestor nodes and all
                 such ancestor nodes have exactly the same creation and
                 deletiondates. False otherwise.
        &#34;&#34;&#34;
        ancestors = self.get_ancestors()
        if len(ancestors) &lt; 2:
            # We need at least two ancestors for them to have matching dates
            return False
        start_date = ancestors[0].get_start_date()
        end_date = ancestors[0].get_end_date()
        for ancestor in ancestors[1:]:
            if not ancestor.get_start_date() == start_date:
                return False
            if not ancestor.get_end_date() == end_date:
                return False
        return True

    def do_all_descendant_nodes_share_same_date(self):
        &#34;&#34;&#34;
        :return: True when they are at least two descendant nodes and all
                 such descendant nodes have exactly the same creation and
                 deletiondates. False otherwise.
        &#34;&#34;&#34;
        descendants = self.get_descendants()
        if len(descendants) &lt; 2:
            # We need at least two descendants for them to have matching dates
            return False
        start_date = descendants[0].get_start_date()
        end_date = descendants[0].get_end_date()
        for descendant in descendants[1:]:
            if not descendant.get_start_date() == start_date:
                return False
            if not descendant.get_end_date() == end_date:
                return False
        return True

    def get_time_stamp(self):
        return int(self.globalid.split(&#39;::&#39;)[0])

    def get_local_id(self):
        return self.globalid.split(&#39;::&#39;)[1]

    def get_global_id(self):
        return self.globalid

    def get_end_date(self):
        return self.end_date

    def set_end_date(self, time_stamp):
        self.end_date = time_stamp

    def get_start_date(self):
        return self.start_date

    def set_start_date(self, time_stamp):
        self.start_date = time_stamp

    def set_creation_date_if_earlier(self, time_stamp):
        &#34;&#34;&#34;
        When the given time_stamp is earlier than the current value of
        the node start_date then set the start_date with that value
        :param time_stamp: the time stamp that should be set when it is earlier
        :return: None
        &#34;&#34;&#34;
        if not self.start_date:
            self.start_date = time_stamp
            return
        if time_stamp &lt; self.start_date:
            self.start_date = time_stamp

    def set_creation_date_recursive(self, time_stamp):
        self.set_creation_date_if_earlier(time_stamp)
        for descendant in self.get_descendants():
            descendant.set_creation_date_recursive(time_stamp)

    def set_deletion_date_if_later(self, time_stamp):
        if not self.end_date:
            self.end_date = time_stamp
            return
        if time_stamp &gt; self.end_date:
            self.end_date = time_stamp

    def get_ancestors(self):
        return [edge.ancestor for edge in self.ancestor_edges]

    def add_ancestor_edge(self, ancestor_edge):
        if not ancestor_edge:
            return
        self.ancestor_edges.append(ancestor_edge)
        if self.is_hapax():
            self.set_end()
        elif self.is_start():
            self.set_link()

    def add_ancestor_edges(self, ancestor_edges_list):
        for edge in ancestor_edges_list:
            self.add_ancestor_edge(edge)

    def get_ancestor_edges(self):
        return self.ancestor_edges

    def get_descendants(self):
        &#34;&#34;&#34;
        :return: the list of the direct descendants (no recursion done)
        &#34;&#34;&#34;
        return [edge.descendant for edge in self.descendant_edges]

    def add_descendant_edge(self, descendant_edge, debug_mode=False):
        if not descendant_edge:
            return
        if debug_mode and descendant_edge in self.descendant_edges:
            print(&#34;The following edge: &#34;)
            pprint(vars(descendant_edge))
            print(&#34;is already part of the descendant edges of this node: &#34;)
            pprint(vars(self))
            print(&#39;Exiting.&#39;)
            sys.exit(1)
        self.descendant_edges.append(descendant_edge)
        if self.is_hapax():
            self.set_start()
        elif self.is_end():
            self.set_link()

    def add_descendant_edges(self, descendant_edge_list):
        for edge in descendant_edge_list:
            self.add_descendant_edge(edge)

    def get_descendant_edges(self):
        return self.descendant_edges

    def reset_descendant_edges(self):
        self.descendant_edges = list()

    def disconnect_adjacent_edges(self):
        self.ancestor_edges = list()
        self.reset_descendant_edges()

    def set_hapax(self, time_stamp):
        if not self.is_unknown():
            print(&#34;Failing to promote as hapax from status: &#34;, self.status)
            sys.exit(1)
        self.status = Node.Status.hapax
        if self.start_date:
            print(&#34;This newly converted hapax already had a start_date.&#34;)
            sys.exit(1)
        self.start_date = time_stamp
        if self.end_date:
            print(&#34;This newly converted hapax already had a end_date.&#34;)
            sys.exit(1)
        self.end_date = time_stamp
        self.assert_status_coherence()

    def set_start(self, time_stamp=None):
        if not self.is_unknown() and not self.is_hapax():
            print(&#34;Failed to define as start.&#34;)
            sys.exit(1)
        if self.is_end():
            print(&#34;Failed to convert an end into being a start.&#34;)
            sys.exit(1)
        if self.is_link():
            print(&#34;Failed to convert a link into being a start.&#34;)
            sys.exit(1)
        self.status = Node.Status.start
        if time_stamp:
            if self.start_date:
                print(&#34;Warning: overwriting a start_date of a new start.&#34;)
            self.start_date = time_stamp
        self.assert_status_coherence()

    def set_end(self, time_stamp=None):
        if not self.is_unknown() and not self.is_hapax():
            print(&#34;Failed to define as end.&#34;)
            sys.exit(1)
        if self.is_start():
            print(&#34;Failed to convert a start into being a end.&#34;)
            sys.exit(1)
        if self.is_link():
            print(&#34;Failed to convert a link into being an end.&#34;)
            sys.exit(1)
        self.status = Node.Status.end
        if time_stamp:
            if self.end_date:
                print(&#34;Warning: overwriting a start_date of a new end.&#34;)
            self.end_date = time_stamp
        self.assert_status_coherence()

    def set_link(self):
        if self.is_unknown():
            print(&#34;An unknown node should not be converted to being an link.&#34;)
            sys.exit(1)
        if self.is_hapax():
            print(&#34;An hapax node should not be converted to being an link.&#34;)
            sys.exit(1)
        self.status = Node.Status.link


class Edge(object):
    @unique
    class Tag(Enum):
        &#34;&#34;&#34;
        The edges whose type is &#39;replace&#39; are further distinguished with
        tags that are specified with this enum Class.
        &#34;&#34;&#34;
        unknown = 1
        fused = 2
        modified = 3
        re_ided = 4
        subdivided = 5
        unchanged = 6

    def __init__(self, **kwargs):
        # Attributes that will be dynamically added by the Json parsing
        # An integer used as Node identifier (local to a single Graph file)
        self.id = None
        # An integer index designating the source Node
        self.source = None
        # An integer index designating the target Node
        self.target = None
        # A string among &#39;replace&#39;, &#39;create&#39; and &#39;delete&#39;
        self.type = None
        # A list of tags specified with the Edge.Tag enum. Note that is
        # is a list because some combinations (like being a fusion edge
        # and at the same time a modified edge) must be possible
        self.tags = None
        self.__dict__ = kwargs

        # Refer to Node.file_ids eponymous attribute for comments:
        self.file_ids = &#39;&#39;
        # The Node with self.source as identifier
        self.ancestor = None
        # The Node with self.target as identifier
        self.descendant = None

    def __str__(self):
        ret_str = f&#39;Edge: {self.id} (file ids: {self.file_ids})\n&#39;
        ret_str += f&#39;  Ancestor: {self.ancestor.globalid}&#39;
        ret_str += f&#39; (id: {self.ancestor.id})\n&#39;
        ret_str += f&#39;  Descendant: {self.descendant.globalid}&#39;
        ret_str += f&#39; (id: {self.descendant.id})\n&#39;
        ret_str += f&#39;  Tags: {self.tags}\n&#39;
        return ret_str

    def is_tag_in_tags(self, tag_to_test):
        return any(tag_to_test == tag for tag in self.tags)

    def is_replace(self):
        if self.type == &#39;replace&#39;:
            return True
        return False

    def is_unchanged(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.unchanged):
            return True
        return False

    def is_subdivided(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.subdivided):
            return True
        return False

    def is_re_ided(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.re_ided):
            return True
        return False

    def is_modified(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.modified):
            return True
        return False

    def is_fusion(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.fused):
            return True
        return False

    def is_of_type(self, edge_tag):
        if edge_tag == Edge.Tag.unchanged and self.is_unchanged():
            return True
        if edge_tag == Edge.Tag.subdivided and self.is_subdivided():
            return True
        if edge_tag == Edge.Tag.re_ided and self.is_re_ided():
            return True
        if edge_tag == Edge.Tag.modified and self.is_modified():
            return True
        if edge_tag == Edge.Tag.fused and self.is_fusion():
            return True
        return False

    def set_ancestor(self, ancestor_node):
        self.ancestor = ancestor_node
        if ancestor_node:
            ancestor_node.add_descendant_edge(self)

    def get_ancestor(self):
        return self.ancestor

    def set_descendant(self, descendant_node):
        self.descendant = descendant_node
        if descendant_node:
            descendant_node.add_ancestor_edge(self)

    def get_descendant(self):
        return self.descendant

    def set_tag_from_string(self, tag):
        &#34;&#34;&#34;
        :param tag: a string corresponding to an Edge.Tag value
        &#34;&#34;&#34;
        self.tags = list()
        self.tags.append(Edge.Tag[tag])

    def set_modified(self):
        self.type = &#39;replace&#39;
        self.append_tag(Edge.Tag.modified)

    def append_tag(self, tag):
        self.tags.append(tag)

    def are_adjacent_nodes_one_to_one(self):
        &#34;&#34;&#34;
        :return: True iif the ancestor node only has a single descendant edge
                (that has to be this one) AND the descendant node only has a
                single ancestor edge (that must also be this one). False
                otherwise.
        &#34;&#34;&#34;
        if len(self.ancestor.get_descendant_edges()) != 1:
            return False
        if len(self.descendant.get_ancestor_edges()) != 1:
            return False
        return True


class Graph(object):

    def __init__(self, nodes=None, edges=None):
        if not nodes:
            self.nodes = list()
        else:
            self.nodes = nodes
        if not edges:
            self.edges = list()
        else:
            self.edges = edges

    def extend_with_subgraph(self, sub_graph):
        # Concerning the nodes of sub_graph we have two possibilities
        # - the node with corresponding globalid already exists in this
        #   graph in which case we need the edges to point to it
        # - the nodes is new (i.e. the node does not correspond to and existing
        #   node with the same globalid within this graph) and we need to
        #   pour/add in this graph

        # The dictionary having the sub_graph node index as key and this
        # graph node as value
        for node in sub_graph.nodes:
            existing_node = self.find_node_from_global_id(node.globalid)
            if existing_node:
                # We need to rewire the edges to the already existing node
                ancestor_edges = node.get_ancestor_edges()
                if ancestor_edges:
                    for edge in ancestor_edges:
                        edge.set_descendant(existing_node)

                descendant_edges = node.get_descendant_edges()
                if descendant_edges:
                    for edge in descendant_edges:
                        edge.set_ancestor(existing_node)

                # Keep a trace of the identification of the nodes
                existing_node.file_ids += f&#39;{node.id}, &#39;
            else:
                # No edge rewiring required. We simply need to add the
                # new sub-graph node to the this graph and change its
                # id to avoid id collisions:
                node.file_ids += f&#39;{node.id}, &#39;
                node.id = len(self.nodes) + 1
                self.nodes.append(node)

        # All sub-graph edges (rewired or not) must be kept and thus get
        # poured/blended within this graph:
        for new_edge in sub_graph.edges:
            new_edge.file_ids += f&#39;{new_edge.id}, &#39;
            new_edge.id = len(self.edges) + 1
            self.edges.append(new_edge)

    def add_node(self, new_node):
        self.nodes.append(new_node)

    def find_node_from_global_id(self, globalid):
        &#34;&#34;&#34;
        Retrieve, when it exists, the node with the given globalid
        :param globalid: the global id that is looked for
        :return: the node with globalid when found, None otherwise
        &#34;&#34;&#34;
        encountered = [node for node in self.nodes if node.globalid == globalid]
        if len(encountered) == 0:
            return None
        elif len(encountered) == 1:
            return encountered[0]
        else:
            print(f&#39;Many nodes with same globalid: {globalid}&#39;)
            pprint(vars(encountered))
            sys.exit()

    @classmethod
    def find_node_from_id(cls, list_of_nodes, id):
        &#34;&#34;&#34;
        Retrieve, when it exists, the node with the given id
        :param list_of_nodes: the list of nodes that should we inquired
        :param id: the id that is looked for
        :return: the node with id when found, None otherwise
        &#34;&#34;&#34;
        encountered = [node for node in list_of_nodes if node.id == id]
        if len(encountered) == 0:
            return None
        elif len(encountered) == 1:
            return encountered[0]
        else:
            print(f&#39;Many nodes with same id: {id}&#39;)
            pprint(vars(encountered))
            sys.exit()

    def delete_node(self, node, deep_assert=False):
        &#34;&#34;&#34;
        Assert this node has no adjacent edge that it knows about and delete
        it from the graph.
        :param node: the node to be removed
        :param deep_assert: when true, assert that no other edge of the graph
                            (that the node wouldn&#39;t know about) is pointing to
                            the argument node
        :return: True when properly deleted, sys.exit() otherwiwe
        &#34;&#34;&#34;
        if node.get_ancestors() or node.get_descendants():
            print(&#39;Cannot delete following node with ancestors or descendants&#39;)
            pprint(vars(node))
            sys.exit()
        if deep_assert:
            for edge in self.edges:
                if edge.get_ancestor() == node or edge.get_descendant() == node:
                    print(&#39;Cannot delete following node:&#39;)
                    pprint(vars(node))
                    print(&#39;   because it is refered by following edge:&#39;)
                    pprint(vars(edge))
                    sys.exit()
        if node not in self.nodes:
            print(&#39;Cannot delete following node:&#39;)
            pprint(vars(node))
            print(&#39;   because it is not in the graph nodes.&#39;)
            sys.exit()
        self.nodes.remove(node)
        return True

    def disconnect_edge(self, edge):
        &#34;&#34;&#34;
        Isolate this edge from its adjacent nodes and tell those adjacent
        nodes to forget about the existence of this edge. This method
        is usually called prior to delete_edge.
        :param edge: the edge to be disconnected.
        &#34;&#34;&#34;
        # Clean up the ancestor and descendant nodes:
        if not edge.ancestor:
            print(&#39;The following edge has no ancestor:&#39;)
            pprint(vars(edge))
            print(&#39;Exiting.&#39;)
            sys.exit(1)
        descendant_edges = edge.ancestor.get_descendant_edges()
        if edge in descendant_edges:
            descendant_edges.remove(edge)

        if not edge.descendant:
            print(&#39;The following edge has no ancestor:&#39;)
            pprint(vars(edge))
            print(&#39;Exiting.&#39;)
            sys.exit(1)
        ancestor_edges = edge.descendant.get_ancestor_edges()
        if edge in ancestor_edges:
            ancestor_edges.remove(edge)

        # We finish will un-connecting the edge per-se
        edge.set_ancestor(None)
        edge.set_descendant(None)

    def delete_edge(self, edge, deep_assert=False):
        &#34;&#34;&#34;
        Assert this edge has no adjacent nodes (that it knows about) and delete
        it from the graph.
        :param edge: the edge to be removed
        :param deep_assert: when true, assert that no other node of the graph
                            (that the edge wouldn&#39;t know about) is pointing to
                            the argument edge
        :return: True when properly deleted, sys.exit() otherwiwe
        &#34;&#34;&#34;
        if edge.get_ancestor() or edge.get_descendant():
            print(&#39;Cannot delete following edge with an ancestor or descendant&#39;)
            pprint(vars(edge))
            sys.exit()
        if deep_assert:
            for node in self.nodes:
                if edge in node.get_ancestor_edges():
                    print(&#39;Cannot delete following edge:&#39;)
                    pprint(vars(edge))
                    print(&#39;   because it is an ancestor edge of following node:&#39;)
                    pprint(vars(node))
                    sys.exit()
                if edge in node.get_descendant_edges():
                    print(&#39;Cannot delete following edge:&#39;)
                    pprint(vars(edge))
                    print(&#39;   because it is a descendant edge of following node:&#39;)
                    pprint(vars(node))
                    sys.exit()
        self.edges.remove(edge)
        return True

    def collapse_edge_and_remove_ancestor(self, edge, debug_mode=False):
        &#34;&#34;&#34;
        Collapse the given edge that is
         - take all the ancestor edges of the ancestor of the argument edge
           and make them ancestor edges of the descendant of that argument edge
         - remove the argument edge from the list of ancestor_edges
         - remove the argument edge from the graph
         - set the start date of the descendant of the argument edge as being
           the start date of the ancestor of the argument edge
        :param edge: the edge that should be removed
        :param debug_mode: when True assume something is wrong and realize
                           additional sanity checks
        :return: True when edge removed, sys.exit() otherwise
        &#34;&#34;&#34;
        ancestor = edge.get_ancestor()
        descendant = edge.get_descendant()
        ancestor_edges = ancestor.get_ancestor_edges()

        # Rewire the ancestor_edges to the descendant
        if ancestor_edges:
            for ancestor_edge in ancestor_edges:
                ancestor_edge.set_descendant(descendant)
            # Conversely, let the descendant know about its new ancestor edges
            descendant.add_ancestor_edges(ancestor_edges)

        # Disconnect the ancestor node from all its adjacent edges
        ancestor.disconnect_adjacent_edges()

        # We must now proceed with isolating/un-connecting the edge
        self.disconnect_edge(edge)

        # Both the ancestor node and the edge to be collapsed are now isolated
        # from the graph. We can proceed with their removal:
        self.delete_node(ancestor, debug_mode)
        self.delete_edge(edge, debug_mode)

        return True

    def split_edge_and_remove_descendant(self, edge, debug_mode=False):
        &#34;&#34;&#34;
        Split the given edge that is
         - take all the descendant edges of the descendant of the argument edge
           and make them descendant edges of the ancestor of that argument edge
         - remove the argument edge from the list of descendant_edges (of
           the ancestor for the argument edge)
         - remove the argument edge from the graph
         - set the start date of the descendants of the descendant of argument
           edge as being the start date of the descendant of the argument edge
        :param edge: the edge that should split (and technically removed)
        :param debug_mode: when True assume something is wrong and realize
                           additional sanity checks
        :return: True when edge removed, sys.exit() otherwise
        &#34;&#34;&#34;

        ancestor = edge.get_ancestor()
        descendant = edge.get_descendant()
        descendant_edges = descendant.get_descendant_edges()

        # Rewire the ancestor of descendant_edges (of the descendant) to
        # being the ancestor
        if descendant_edges:
            for descendant_edge in descendant_edges:
                descendant_edge.set_ancestor(ancestor)
            # Conversely, let the ancestor node know it has new descendant
            # edges (acting as the split versions of the argument edge)
            ancestor.add_descendant_edge(descendant_edge)

        # Disconnect the descendant node from all its adjacent edges
        descendant.disconnect_adjacent_edges()

        # We must now proceed with isolating/un-connecting the edge
        self.disconnect_edge(edge)

        # Both the descendant node and the edge to be collapsed are now isolated
        # from the graph. We can proceed with their removal:
        self.delete_node(descendant, debug_mode)
        self.delete_edge(edge, debug_mode)

        return True

    def display_characteristics(self, indent=&#34;&#34;):
        print(indent + &#34;Nodes: total number&#34;, len(self.nodes))
        edges_number = len(self.edges)
        modified_edges_number = \
            len([e for e in self.edges if e.is_modified()])
        re_ided_edges_number = \
            len([e for e in self.edges if e.is_re_ided()])
        subdivision_edges_number = \
            len([e for e in self.edges if e.is_subdivided()])
        fusion_edges_number = \
            len([e for e in self.edges if e.is_fusion()])
        unchanged_edges_number = \
            len([e for e in self.edges if e.is_unchanged()])
        replacement_edges_number = modified_edges_number \
            + re_ided_edges_number \
            + subdivision_edges_number \
            + fusion_edges_number \
            + unchanged_edges_number

        print(indent + &#34;Edges: total number&#34;, edges_number)
        print(indent + &#34;  - modified edges: &#34;, modified_edges_number)
        print(indent + &#34;  - re-ided edges: &#34;, re_ided_edges_number)
        print(indent + &#34;  - subdivision edges: &#34;, subdivision_edges_number)
        print(indent + &#34;  - fusion edges: &#34;, fusion_edges_number)
        print(indent + &#34;  - unchanged edges: &#34;, unchanged_edges_number)
        print(indent + &#34;  - replace edges total&#34;, replacement_edges_number)
        if edges_number != replacement_edges_number:
            print(indent + &#34;WARNING: missmatching number of edges&#34;)

    def print_nodes_and_edges(self):
        for node in self.nodes:
            if node.is_unknown():
                print(&#34;A node with unknown status was found:&#34;)
                pprint(vars(node))
                sys.exit(1)
            print(node)

        for edge in self.edges:
            print(edge)


class GraphMLDecoder(json.JSONDecoder):
    def __init__(self):
        json.JSONDecoder.__init__(self, object_hook=self.dict_to_object)

    def dict_to_object(self, dct):
        if &#39;id&#39; in dct and &#39;globalid&#39; in dct:
            return Node(**dct)
        if &#39;id&#39; in dct \
                and &#39;source&#39; in dct \
                and &#39;target&#39; in dct \
                and &#39;type&#39; in dct \
                and &#39;tags&#39; in dct:
            edge = Edge(**dct)
            # Because the Json deserializer will make edge.tags a string
            # (as opposed to a list), and because we found it messy to
            # fix that in the Edge constructor, we &#34;fix&#34; things here.
            # That is we manually convert the tags value that was set
            # (as a string) into a list with and Edge.Tag
            if edge.tags == &#39;re-ided&#39;:
                # This is special case is due to the fact that an enum
                # name of re-ided is not possible (is in interpreted as
                # a minus operation (between re and ided) in the definition
                # of the enum
                edge.set_tag_from_string(&#39;re_ided&#39;)
            else:
                edge.set_tag_from_string(edge.tags)
            return edge
        return dct


class TemporalGraph(Graph):

    def __init__(self, cli_args):
        Graph.__init__(self)
        self.cli_args = cli_args

    def extract_time_stamps(self):
        &#34;&#34;&#34;
        :return: the ordered (from oldest to most recent) list of time stamps
                 as extracted from the node&#39;s global identifiers.
        &#34;&#34;&#34;
        time_stamps_set = set()
        for node in self.nodes:
            time_stamps_set.add(node.get_time_stamp())
        time_stamps = list(time_stamps_set)
        time_stamps.sort()
        return time_stamps

    def get_nodes_with_time_stamp(self, time_stamp):
        if isinstance(time_stamp, str):
            time_stamp = int(time_stamp)
        return [n for n in self.nodes if n.get_time_stamp() == time_stamp]

    def reconstruct_connectivity(self):
        debug_msg(&#34;Reconstructing graph: &#34;)
        debug_msg(&#34;   Loading nodes and edges of files: &#34;)
        # Deserialize the temporal (sub) graphs to constitute the general graph
        for temporal_graph_filename in self.cli_args.temporal_graph:
            with open(temporal_graph_filename, &#39;r&#39;) as temporal_graph_file:
                temporal_graph = json.loads(temporal_graph_file.read(),
                                            cls=GraphMLDecoder)

            current_nodes = temporal_graph[&#39;nodes&#39;]
            # Because the Json GraphML we parse is produced with boost::ptree&#39;s
            # write_json method that is well known for not conforming to Json
            # (integers are serialized as strings i.e. enclosed with double quotes)
            # we need to &#34;fix&#34; things after the Json parser is run
            for node in current_nodes:
                if isinstance(node.id, str):
                    node.id = int(node.id)

            current_edges = temporal_graph[&#39;edges&#39;]
            # Edges id must also be type fixed (refer above to current_nodes)
            for edge in current_edges:
                if isinstance(edge.id, str):
                    edge.id = int(edge.id)

            # Additionally we need to replace the node indexes (integer) loaded
            # as source and target (with the Json type fix) to their corresponding
            # references (as python objects):
            for edge in current_edges:
                if isinstance(edge.source, str):
                    edge.set_ancestor(Graph.find_node_from_id(
                        current_nodes, int(edge.source)))
                if isinstance(edge.target, str):
                    edge.set_descendant(Graph.find_node_from_id(
                        current_nodes, int(edge.target)))

            # Eventually we can append the current graph:
            if not self.nodes:
                Graph.__init__(self, current_nodes, current_edges)
            else:
                self.extend_with_subgraph(Graph(current_nodes, current_edges))
            debug_msg(&#34;   &#34; + str(temporal_graph_filename) + &#34;: done.&#34;)
        debug_msg(&#34;  Loading of files: done.&#34;)
        debug_msg(&#34;Graph reconstruction: done.&#34;)

    def remove_replicate_descendant_edges(self, node):
        &#34;&#34;&#34;
        When two nodes have multiple adjacent edges (that there exists at least
        two edges that are adjacent to same two nodes) then wish to remove the
        replicates in order to leave a single edge.
        This method considers all the descendant edges of the provided
        argument node, looks for replicates and removes them.
        :param node: the considered node
        :return: the number of edges that were removed
        &#34;&#34;&#34;
        number_removed_edges = 0
        seen_node = set()
        for descendant_edge in node.get_descendant_edges():
            descendant = descendant_edge.get_descendant()
            descendant_id = descendant.get_global_id()
            if descendant_id in seen_node:
                # This is a replicate edge that we trash.
                self.disconnect_edge(descendant_edge)
                # Note that we don&#39;t need to inspect for other nodes &#34;knowing&#34;
                # (refering to) that edge because we knew both its endpoints
                # that disconnecting the edge got those nodes informed
                self.delete_edge(descendant_edge, False)
                number_removed_edges += 1
            else:
                seen_node.add(descendant_id)
        return number_removed_edges

    def simplify(self, display_characteristics=False):
        debug_msg(&#34;Simplifying the graph:&#34;)
        # At this point we have lineage information at hand in the form of the
        # reconstructed graph. We still have to simplify that graph in order
        # to re-interpret the available lineages at the level of the objects
        # (the buildings in this application). For example if the building B_1 is
        # present for year Y1, Y2 and Y3 and the land-print (geometry) of the
        # building remains unchanged during those years (same geometry) then
        # we can abstract such a situation by stating (in a 3DTiles temporal
        # framework) that building B_1 has a creation date of Y1 and a deletion
        # date of Y3. In other terms we simplified the sub-graph
        #                 unchanged               unchanged
        #     [B_1, Y1] ------------&gt; [B_1, Y2] -------------&gt; [B_1, Y3]
        # to be reduced to a single node/vertex
        #                           [B_1, Y1-Y3]
        # For more complicated cases (e.g. when the geometry gets modified), the
        # simplified graph will still posses edges that will need to be
        # represented (within the resulting tileset) as (3DTiles) temporal
        # transactions.
        #
        # In the following simplification process note that we iterate over
        # the time stamps in order to apply some graph simplification (empirical)
        # rules. When doing so we start from the past (oldest time stamps) and
        # proceed towards the future (the most recent time stamps). The reason
        # for this past to future time oriented sweeping process (as opposed to
        # random order or from future to past) is to obtain a simplified graph
        # that keeps the most recent building geometries (and removes the oldest
        # nodes i.e. the most ancient building geometries). The assumption behind
        # such time stamp sweeping strategy is that most recent city descriptions
        # are also the most detailed.

        time_stamps = self.extract_time_stamps()

        debug_msg(&#34;  Stage 0: removing duplicate edges.&#34;)
        duplicates = 0
        for time_stamp in time_stamps:
            current_nodes = self.get_nodes_with_time_stamp(time_stamp)
            for node in current_nodes:
                duplicates += self.remove_replicate_descendant_edges(node)
        if duplicates:
            debug_msg(f&#39;    Number of removed duplicates edges: {duplicates}&#39;)
        else:
            debug_msg(&#39;    No duplicates edges found.&#39;)

        # Note that the relative order of application of the following
        # simplification strategies (labeled as stages) does matter. In particular
        #  - collapsing unchanged/re-ided 1 to 1 edges should NOT be realized
        #    prior to collapsing fusion edges, but
        #  - collapsing unchanged/re-ided 1 to 1 edges MUST be realized prior to
        #    collapsing subdivision edges
        # The above constraints on relative order leave a single ordering
        # possibility that is thus used below.

        debug_msg(&#34;  Stage 1: collapsing unchanged/re-ided 1 to 1 edges.&#34;)
        initial_number_one_to_one_edges = \
            len([e for e in self.edges if e.are_adjacent_nodes_one_to_one() and (e.is_unchanged() or e.is_re_ided())])
        one_to_one_number = 0
        to_remove = self.edges.copy()
        for edge in to_remove:
            if not edge.are_adjacent_nodes_one_to_one():
                continue
            if edge.is_unchanged() or edge.is_re_ided():
                ancestor = edge.get_ancestor()
                descendant = edge.get_descendant()
                descendant.set_start_date(ancestor.get_start_date())
                self.collapse_edge_and_remove_ancestor(edge, debug_mode)
                one_to_one_number += 1
                debug_msg_ne(f&#39;    Number of collapsed edges: {one_to_one_number} / {initial_number_one_to_one_edges} &#39;)
        debug_msg(f&#39;    Number of collapsed edges: {one_to_one_number} / {initial_number_one_to_one_edges}&#39;)
        if display_characteristics:
            print(&#39;    Resulting graph characteristics&#39;)
            self.display_characteristics(&#39;       &#39;)

        # ############################
        debug_msg(&#34;  Stage 2: collapsing fusion edges.&#34;)
        initial_number_fusion_edges = \
            len([e for e in self.edges if e.is_fusion()])
        fusion_edges_number = 0
        for time_stamp in time_stamps:
            current_nodes = self.get_nodes_with_time_stamp(time_stamp)
            for node in current_nodes:
                if not node.are_all_ancestor_edges_of_type(Edge.Tag.fused):
                    continue
                if not node.do_all_ancestor_nodes_share_same_date():
                    continue
                # We can proceed with the collapsing of all fusion edges
                node.set_start_date(node.get_ancestors()[0].get_start_date())
                # We need to freeze the list of edges to be dealt with (as opposed
                # to using e.g. &#34;for ancestor_edge in node.get_ancestor_edges()&#34;)
                # because the operator used within the loop possibly modifies
                # that list by adding new edges (that we don&#39;t want to delete)
                # on the fly:
                ancestor_edges = node.get_ancestor_edges().copy()
                for ancestor_edge in ancestor_edges:
                    self.collapse_edge_and_remove_ancestor(ancestor_edge,
                                                           debug_mode)
                number_fusion_edges_left = \
                    len([e for e in self.edges if e.is_fusion()])
                fusion_edges_number = initial_number_fusion_edges \
                    - number_fusion_edges_left
                debug_msg_ne(f&#39;    Number of fusion edges: {fusion_edges_number} / {initial_number_fusion_edges} &#39;)
        debug_msg(f&#39;    Number of fusion edges: {fusion_edges_number} / {initial_number_fusion_edges} &#39;)
        if display_characteristics:
            print(&#39;    Resulting graph characteristics&#39;)
            self.display_characteristics(&#39;       &#39;)

        # #######################
        debug_msg(&#34;  Stage 3: collapsing subdivision edges.&#34;)

        initial_number_fusion_edges = \
            len([e for e in self.edges if e.is_subdivided()])
        number_deleted_edges = 0
        debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
        for time_stamp in time_stamps:
            current_nodes = self.get_nodes_with_time_stamp(time_stamp)
            for node in current_nodes:
                if not node.are_all_descendant_edges_of_type(
                        Edge.Tag.subdivided):
                    continue
                if not node.do_all_descendant_nodes_share_same_date():
                    continue
                ancestor_edges = node.get_ancestor_edges()
                if len(ancestor_edges) &gt; 1:
                    # The proper/clean way of dealing with a subdivided node that
                    # has more thatn one ancestors is not yet established. For
                    # the time being we thus leave such a situation untouched.
                    continue

                # Whether the is no ancestor at all or only one we shall proceed
                # with the &#34;split&#34; of all subdivision edges. For both cases we
                # shall propagate the creation date:
                for descendant_node in node.get_descendants():
                    descendant_node.set_start_date(node.get_start_date())

                if len(ancestor_edges) == 0:
                    # Because we already propagated the creation date of the node
                    # (to its descendants), the set of the descendants capture all
                    # the geometry for the current time stamp. We can thus get
                    # git of the present node and all the sub-division edges
                    # without loss of information (in fact this sub-division was
                    # not a geometrical one but a logical one).
                    for descendant_edge in node.get_descendant_edges().copy():
                        self.disconnect_edge(descendant_edge)
                        self.delete_edge(descendant_edge, True)
                        number_deleted_edges += 1
                        debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)

                    # We can proceed with the removal of the node:
                    self.delete_node(node, debug_mode)

                else:   # This means there is a single ancestor edge
                    # We shall re-label all the sub-divided edges that we deal
                    # with (below) as &#39;modified&#39; so when we build the corresponding
                    # transaction we have a trace that this was a sub-division case
                    # with modification:
                    for descendant_edge in node.get_descendant_edges():
                        descendant_edge.set_modified()
                    ancestor_edge = ancestor_edges[0]
                    if not ancestor_edge.is_modified():
                        print(&#34;All non modified edges should have been collapsed.&#34;)
                        print(&#34;Yet, the following edge is not:&#34;)
                        pprint(vars(ancestor_edge))
                        print(&#34;Exiting&#34;)
                        sys.exit(1)
                    self.split_edge_and_remove_descendant(ancestor_edge,
                                                          debug_mode)
                    number_deleted_edges += 1
                    debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
        debug_msg(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
        if display_characteristics:
            print(&#39;    Resulting graph characteristics&#39;)
            self.display_characteristics(&#39;       &#39;)

        debug_msg(&#34;Simplifying the graph: done.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(object):
    @unique
    class Tag(Enum):
        &#34;&#34;&#34;
        The edges whose type is &#39;replace&#39; are further distinguished with
        tags that are specified with this enum Class.
        &#34;&#34;&#34;
        unknown = 1
        fused = 2
        modified = 3
        re_ided = 4
        subdivided = 5
        unchanged = 6

    def __init__(self, **kwargs):
        # Attributes that will be dynamically added by the Json parsing
        # An integer used as Node identifier (local to a single Graph file)
        self.id = None
        # An integer index designating the source Node
        self.source = None
        # An integer index designating the target Node
        self.target = None
        # A string among &#39;replace&#39;, &#39;create&#39; and &#39;delete&#39;
        self.type = None
        # A list of tags specified with the Edge.Tag enum. Note that is
        # is a list because some combinations (like being a fusion edge
        # and at the same time a modified edge) must be possible
        self.tags = None
        self.__dict__ = kwargs

        # Refer to Node.file_ids eponymous attribute for comments:
        self.file_ids = &#39;&#39;
        # The Node with self.source as identifier
        self.ancestor = None
        # The Node with self.target as identifier
        self.descendant = None

    def __str__(self):
        ret_str = f&#39;Edge: {self.id} (file ids: {self.file_ids})\n&#39;
        ret_str += f&#39;  Ancestor: {self.ancestor.globalid}&#39;
        ret_str += f&#39; (id: {self.ancestor.id})\n&#39;
        ret_str += f&#39;  Descendant: {self.descendant.globalid}&#39;
        ret_str += f&#39; (id: {self.descendant.id})\n&#39;
        ret_str += f&#39;  Tags: {self.tags}\n&#39;
        return ret_str

    def is_tag_in_tags(self, tag_to_test):
        return any(tag_to_test == tag for tag in self.tags)

    def is_replace(self):
        if self.type == &#39;replace&#39;:
            return True
        return False

    def is_unchanged(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.unchanged):
            return True
        return False

    def is_subdivided(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.subdivided):
            return True
        return False

    def is_re_ided(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.re_ided):
            return True
        return False

    def is_modified(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.modified):
            return True
        return False

    def is_fusion(self):
        if self.is_replace() and self.is_tag_in_tags(Edge.Tag.fused):
            return True
        return False

    def is_of_type(self, edge_tag):
        if edge_tag == Edge.Tag.unchanged and self.is_unchanged():
            return True
        if edge_tag == Edge.Tag.subdivided and self.is_subdivided():
            return True
        if edge_tag == Edge.Tag.re_ided and self.is_re_ided():
            return True
        if edge_tag == Edge.Tag.modified and self.is_modified():
            return True
        if edge_tag == Edge.Tag.fused and self.is_fusion():
            return True
        return False

    def set_ancestor(self, ancestor_node):
        self.ancestor = ancestor_node
        if ancestor_node:
            ancestor_node.add_descendant_edge(self)

    def get_ancestor(self):
        return self.ancestor

    def set_descendant(self, descendant_node):
        self.descendant = descendant_node
        if descendant_node:
            descendant_node.add_ancestor_edge(self)

    def get_descendant(self):
        return self.descendant

    def set_tag_from_string(self, tag):
        &#34;&#34;&#34;
        :param tag: a string corresponding to an Edge.Tag value
        &#34;&#34;&#34;
        self.tags = list()
        self.tags.append(Edge.Tag[tag])

    def set_modified(self):
        self.type = &#39;replace&#39;
        self.append_tag(Edge.Tag.modified)

    def append_tag(self, tag):
        self.tags.append(tag)

    def are_adjacent_nodes_one_to_one(self):
        &#34;&#34;&#34;
        :return: True iif the ancestor node only has a single descendant edge
                (that has to be this one) AND the descendant node only has a
                single ancestor edge (that must also be this one). False
                otherwise.
        &#34;&#34;&#34;
        if len(self.ancestor.get_descendant_edges()) != 1:
            return False
        if len(self.descendant.get_ancestor_edges()) != 1:
            return False
        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.Tag"><code class="name">var <span class="ident">Tag</span></code></dt>
<dd>
<div class="desc"><p>The edges whose type is 'replace' are further distinguished with
tags that are specified with this enum Class.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.append_tag"><code class="name flex">
<span>def <span class="ident">append_tag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_tag(self, tag):
    self.tags.append(tag)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.are_adjacent_nodes_one_to_one"><code class="name flex">
<span>def <span class="ident">are_adjacent_nodes_one_to_one</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True iif the ancestor node only has a single descendant edge
(that has to be this one) AND the descendant node only has a
single ancestor edge (that must also be this one). False
otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def are_adjacent_nodes_one_to_one(self):
    &#34;&#34;&#34;
    :return: True iif the ancestor node only has a single descendant edge
            (that has to be this one) AND the descendant node only has a
            single ancestor edge (that must also be this one). False
            otherwise.
    &#34;&#34;&#34;
    if len(self.ancestor.get_descendant_edges()) != 1:
        return False
    if len(self.descendant.get_ancestor_edges()) != 1:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.get_ancestor"><code class="name flex">
<span>def <span class="ident">get_ancestor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ancestor(self):
    return self.ancestor</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.get_descendant"><code class="name flex">
<span>def <span class="ident">get_descendant</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_descendant(self):
    return self.descendant</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.is_fusion"><code class="name flex">
<span>def <span class="ident">is_fusion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_fusion(self):
    if self.is_replace() and self.is_tag_in_tags(Edge.Tag.fused):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.is_modified"><code class="name flex">
<span>def <span class="ident">is_modified</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_modified(self):
    if self.is_replace() and self.is_tag_in_tags(Edge.Tag.modified):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.is_of_type"><code class="name flex">
<span>def <span class="ident">is_of_type</span></span>(<span>self, edge_tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_of_type(self, edge_tag):
    if edge_tag == Edge.Tag.unchanged and self.is_unchanged():
        return True
    if edge_tag == Edge.Tag.subdivided and self.is_subdivided():
        return True
    if edge_tag == Edge.Tag.re_ided and self.is_re_ided():
        return True
    if edge_tag == Edge.Tag.modified and self.is_modified():
        return True
    if edge_tag == Edge.Tag.fused and self.is_fusion():
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.is_re_ided"><code class="name flex">
<span>def <span class="ident">is_re_ided</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_re_ided(self):
    if self.is_replace() and self.is_tag_in_tags(Edge.Tag.re_ided):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.is_replace"><code class="name flex">
<span>def <span class="ident">is_replace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_replace(self):
    if self.type == &#39;replace&#39;:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.is_subdivided"><code class="name flex">
<span>def <span class="ident">is_subdivided</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_subdivided(self):
    if self.is_replace() and self.is_tag_in_tags(Edge.Tag.subdivided):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.is_tag_in_tags"><code class="name flex">
<span>def <span class="ident">is_tag_in_tags</span></span>(<span>self, tag_to_test)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_tag_in_tags(self, tag_to_test):
    return any(tag_to_test == tag for tag in self.tags)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.is_unchanged"><code class="name flex">
<span>def <span class="ident">is_unchanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_unchanged(self):
    if self.is_replace() and self.is_tag_in_tags(Edge.Tag.unchanged):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.set_ancestor"><code class="name flex">
<span>def <span class="ident">set_ancestor</span></span>(<span>self, ancestor_node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ancestor(self, ancestor_node):
    self.ancestor = ancestor_node
    if ancestor_node:
        ancestor_node.add_descendant_edge(self)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.set_descendant"><code class="name flex">
<span>def <span class="ident">set_descendant</span></span>(<span>self, descendant_node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_descendant(self, descendant_node):
    self.descendant = descendant_node
    if descendant_node:
        descendant_node.add_ancestor_edge(self)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.set_modified"><code class="name flex">
<span>def <span class="ident">set_modified</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_modified(self):
    self.type = &#39;replace&#39;
    self.append_tag(Edge.Tag.modified)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Edge.set_tag_from_string"><code class="name flex">
<span>def <span class="ident">set_tag_from_string</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"><p>:param tag: a string corresponding to an Edge.Tag value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tag_from_string(self, tag):
    &#34;&#34;&#34;
    :param tag: a string corresponding to an Edge.Tag value
    &#34;&#34;&#34;
    self.tags = list()
    self.tags.append(Edge.Tag[tag])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>nodes=None, edges=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(object):

    def __init__(self, nodes=None, edges=None):
        if not nodes:
            self.nodes = list()
        else:
            self.nodes = nodes
        if not edges:
            self.edges = list()
        else:
            self.edges = edges

    def extend_with_subgraph(self, sub_graph):
        # Concerning the nodes of sub_graph we have two possibilities
        # - the node with corresponding globalid already exists in this
        #   graph in which case we need the edges to point to it
        # - the nodes is new (i.e. the node does not correspond to and existing
        #   node with the same globalid within this graph) and we need to
        #   pour/add in this graph

        # The dictionary having the sub_graph node index as key and this
        # graph node as value
        for node in sub_graph.nodes:
            existing_node = self.find_node_from_global_id(node.globalid)
            if existing_node:
                # We need to rewire the edges to the already existing node
                ancestor_edges = node.get_ancestor_edges()
                if ancestor_edges:
                    for edge in ancestor_edges:
                        edge.set_descendant(existing_node)

                descendant_edges = node.get_descendant_edges()
                if descendant_edges:
                    for edge in descendant_edges:
                        edge.set_ancestor(existing_node)

                # Keep a trace of the identification of the nodes
                existing_node.file_ids += f&#39;{node.id}, &#39;
            else:
                # No edge rewiring required. We simply need to add the
                # new sub-graph node to the this graph and change its
                # id to avoid id collisions:
                node.file_ids += f&#39;{node.id}, &#39;
                node.id = len(self.nodes) + 1
                self.nodes.append(node)

        # All sub-graph edges (rewired or not) must be kept and thus get
        # poured/blended within this graph:
        for new_edge in sub_graph.edges:
            new_edge.file_ids += f&#39;{new_edge.id}, &#39;
            new_edge.id = len(self.edges) + 1
            self.edges.append(new_edge)

    def add_node(self, new_node):
        self.nodes.append(new_node)

    def find_node_from_global_id(self, globalid):
        &#34;&#34;&#34;
        Retrieve, when it exists, the node with the given globalid
        :param globalid: the global id that is looked for
        :return: the node with globalid when found, None otherwise
        &#34;&#34;&#34;
        encountered = [node for node in self.nodes if node.globalid == globalid]
        if len(encountered) == 0:
            return None
        elif len(encountered) == 1:
            return encountered[0]
        else:
            print(f&#39;Many nodes with same globalid: {globalid}&#39;)
            pprint(vars(encountered))
            sys.exit()

    @classmethod
    def find_node_from_id(cls, list_of_nodes, id):
        &#34;&#34;&#34;
        Retrieve, when it exists, the node with the given id
        :param list_of_nodes: the list of nodes that should we inquired
        :param id: the id that is looked for
        :return: the node with id when found, None otherwise
        &#34;&#34;&#34;
        encountered = [node for node in list_of_nodes if node.id == id]
        if len(encountered) == 0:
            return None
        elif len(encountered) == 1:
            return encountered[0]
        else:
            print(f&#39;Many nodes with same id: {id}&#39;)
            pprint(vars(encountered))
            sys.exit()

    def delete_node(self, node, deep_assert=False):
        &#34;&#34;&#34;
        Assert this node has no adjacent edge that it knows about and delete
        it from the graph.
        :param node: the node to be removed
        :param deep_assert: when true, assert that no other edge of the graph
                            (that the node wouldn&#39;t know about) is pointing to
                            the argument node
        :return: True when properly deleted, sys.exit() otherwiwe
        &#34;&#34;&#34;
        if node.get_ancestors() or node.get_descendants():
            print(&#39;Cannot delete following node with ancestors or descendants&#39;)
            pprint(vars(node))
            sys.exit()
        if deep_assert:
            for edge in self.edges:
                if edge.get_ancestor() == node or edge.get_descendant() == node:
                    print(&#39;Cannot delete following node:&#39;)
                    pprint(vars(node))
                    print(&#39;   because it is refered by following edge:&#39;)
                    pprint(vars(edge))
                    sys.exit()
        if node not in self.nodes:
            print(&#39;Cannot delete following node:&#39;)
            pprint(vars(node))
            print(&#39;   because it is not in the graph nodes.&#39;)
            sys.exit()
        self.nodes.remove(node)
        return True

    def disconnect_edge(self, edge):
        &#34;&#34;&#34;
        Isolate this edge from its adjacent nodes and tell those adjacent
        nodes to forget about the existence of this edge. This method
        is usually called prior to delete_edge.
        :param edge: the edge to be disconnected.
        &#34;&#34;&#34;
        # Clean up the ancestor and descendant nodes:
        if not edge.ancestor:
            print(&#39;The following edge has no ancestor:&#39;)
            pprint(vars(edge))
            print(&#39;Exiting.&#39;)
            sys.exit(1)
        descendant_edges = edge.ancestor.get_descendant_edges()
        if edge in descendant_edges:
            descendant_edges.remove(edge)

        if not edge.descendant:
            print(&#39;The following edge has no ancestor:&#39;)
            pprint(vars(edge))
            print(&#39;Exiting.&#39;)
            sys.exit(1)
        ancestor_edges = edge.descendant.get_ancestor_edges()
        if edge in ancestor_edges:
            ancestor_edges.remove(edge)

        # We finish will un-connecting the edge per-se
        edge.set_ancestor(None)
        edge.set_descendant(None)

    def delete_edge(self, edge, deep_assert=False):
        &#34;&#34;&#34;
        Assert this edge has no adjacent nodes (that it knows about) and delete
        it from the graph.
        :param edge: the edge to be removed
        :param deep_assert: when true, assert that no other node of the graph
                            (that the edge wouldn&#39;t know about) is pointing to
                            the argument edge
        :return: True when properly deleted, sys.exit() otherwiwe
        &#34;&#34;&#34;
        if edge.get_ancestor() or edge.get_descendant():
            print(&#39;Cannot delete following edge with an ancestor or descendant&#39;)
            pprint(vars(edge))
            sys.exit()
        if deep_assert:
            for node in self.nodes:
                if edge in node.get_ancestor_edges():
                    print(&#39;Cannot delete following edge:&#39;)
                    pprint(vars(edge))
                    print(&#39;   because it is an ancestor edge of following node:&#39;)
                    pprint(vars(node))
                    sys.exit()
                if edge in node.get_descendant_edges():
                    print(&#39;Cannot delete following edge:&#39;)
                    pprint(vars(edge))
                    print(&#39;   because it is a descendant edge of following node:&#39;)
                    pprint(vars(node))
                    sys.exit()
        self.edges.remove(edge)
        return True

    def collapse_edge_and_remove_ancestor(self, edge, debug_mode=False):
        &#34;&#34;&#34;
        Collapse the given edge that is
         - take all the ancestor edges of the ancestor of the argument edge
           and make them ancestor edges of the descendant of that argument edge
         - remove the argument edge from the list of ancestor_edges
         - remove the argument edge from the graph
         - set the start date of the descendant of the argument edge as being
           the start date of the ancestor of the argument edge
        :param edge: the edge that should be removed
        :param debug_mode: when True assume something is wrong and realize
                           additional sanity checks
        :return: True when edge removed, sys.exit() otherwise
        &#34;&#34;&#34;
        ancestor = edge.get_ancestor()
        descendant = edge.get_descendant()
        ancestor_edges = ancestor.get_ancestor_edges()

        # Rewire the ancestor_edges to the descendant
        if ancestor_edges:
            for ancestor_edge in ancestor_edges:
                ancestor_edge.set_descendant(descendant)
            # Conversely, let the descendant know about its new ancestor edges
            descendant.add_ancestor_edges(ancestor_edges)

        # Disconnect the ancestor node from all its adjacent edges
        ancestor.disconnect_adjacent_edges()

        # We must now proceed with isolating/un-connecting the edge
        self.disconnect_edge(edge)

        # Both the ancestor node and the edge to be collapsed are now isolated
        # from the graph. We can proceed with their removal:
        self.delete_node(ancestor, debug_mode)
        self.delete_edge(edge, debug_mode)

        return True

    def split_edge_and_remove_descendant(self, edge, debug_mode=False):
        &#34;&#34;&#34;
        Split the given edge that is
         - take all the descendant edges of the descendant of the argument edge
           and make them descendant edges of the ancestor of that argument edge
         - remove the argument edge from the list of descendant_edges (of
           the ancestor for the argument edge)
         - remove the argument edge from the graph
         - set the start date of the descendants of the descendant of argument
           edge as being the start date of the descendant of the argument edge
        :param edge: the edge that should split (and technically removed)
        :param debug_mode: when True assume something is wrong and realize
                           additional sanity checks
        :return: True when edge removed, sys.exit() otherwise
        &#34;&#34;&#34;

        ancestor = edge.get_ancestor()
        descendant = edge.get_descendant()
        descendant_edges = descendant.get_descendant_edges()

        # Rewire the ancestor of descendant_edges (of the descendant) to
        # being the ancestor
        if descendant_edges:
            for descendant_edge in descendant_edges:
                descendant_edge.set_ancestor(ancestor)
            # Conversely, let the ancestor node know it has new descendant
            # edges (acting as the split versions of the argument edge)
            ancestor.add_descendant_edge(descendant_edge)

        # Disconnect the descendant node from all its adjacent edges
        descendant.disconnect_adjacent_edges()

        # We must now proceed with isolating/un-connecting the edge
        self.disconnect_edge(edge)

        # Both the descendant node and the edge to be collapsed are now isolated
        # from the graph. We can proceed with their removal:
        self.delete_node(descendant, debug_mode)
        self.delete_edge(edge, debug_mode)

        return True

    def display_characteristics(self, indent=&#34;&#34;):
        print(indent + &#34;Nodes: total number&#34;, len(self.nodes))
        edges_number = len(self.edges)
        modified_edges_number = \
            len([e for e in self.edges if e.is_modified()])
        re_ided_edges_number = \
            len([e for e in self.edges if e.is_re_ided()])
        subdivision_edges_number = \
            len([e for e in self.edges if e.is_subdivided()])
        fusion_edges_number = \
            len([e for e in self.edges if e.is_fusion()])
        unchanged_edges_number = \
            len([e for e in self.edges if e.is_unchanged()])
        replacement_edges_number = modified_edges_number \
            + re_ided_edges_number \
            + subdivision_edges_number \
            + fusion_edges_number \
            + unchanged_edges_number

        print(indent + &#34;Edges: total number&#34;, edges_number)
        print(indent + &#34;  - modified edges: &#34;, modified_edges_number)
        print(indent + &#34;  - re-ided edges: &#34;, re_ided_edges_number)
        print(indent + &#34;  - subdivision edges: &#34;, subdivision_edges_number)
        print(indent + &#34;  - fusion edges: &#34;, fusion_edges_number)
        print(indent + &#34;  - unchanged edges: &#34;, unchanged_edges_number)
        print(indent + &#34;  - replace edges total&#34;, replacement_edges_number)
        if edges_number != replacement_edges_number:
            print(indent + &#34;WARNING: missmatching number of edges&#34;)

    def print_nodes_and_edges(self):
        for node in self.nodes:
            if node.is_unknown():
                print(&#34;A node with unknown status was found:&#34;)
                pprint(vars(node))
                sys.exit(1)
            print(node)

        for edge in self.edges:
            print(edge)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="py3dtilers.CityTiler.temporal_graph.TemporalGraph" href="#py3dtilers.CityTiler.temporal_graph.TemporalGraph">TemporalGraph</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_id"><code class="name flex">
<span>def <span class="ident">find_node_from_id</span></span>(<span>list_of_nodes, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve, when it exists, the node with the given id
:param list_of_nodes: the list of nodes that should we inquired
:param id: the id that is looked for
:return: the node with id when found, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def find_node_from_id(cls, list_of_nodes, id):
    &#34;&#34;&#34;
    Retrieve, when it exists, the node with the given id
    :param list_of_nodes: the list of nodes that should we inquired
    :param id: the id that is looked for
    :return: the node with id when found, None otherwise
    &#34;&#34;&#34;
    encountered = [node for node in list_of_nodes if node.id == id]
    if len(encountered) == 0:
        return None
    elif len(encountered) == 1:
        return encountered[0]
    else:
        print(f&#39;Many nodes with same id: {id}&#39;)
        pprint(vars(encountered))
        sys.exit()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, new_node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node(self, new_node):
    self.nodes.append(new_node)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.collapse_edge_and_remove_ancestor"><code class="name flex">
<span>def <span class="ident">collapse_edge_and_remove_ancestor</span></span>(<span>self, edge, debug_mode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Collapse the given edge that is
- take all the ancestor edges of the ancestor of the argument edge
and make them ancestor edges of the descendant of that argument edge
- remove the argument edge from the list of ancestor_edges
- remove the argument edge from the graph
- set the start date of the descendant of the argument edge as being
the start date of the ancestor of the argument edge
:param edge: the edge that should be removed
:param debug_mode: when True assume something is wrong and realize
additional sanity checks
:return: True when edge removed, sys.exit() otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collapse_edge_and_remove_ancestor(self, edge, debug_mode=False):
    &#34;&#34;&#34;
    Collapse the given edge that is
     - take all the ancestor edges of the ancestor of the argument edge
       and make them ancestor edges of the descendant of that argument edge
     - remove the argument edge from the list of ancestor_edges
     - remove the argument edge from the graph
     - set the start date of the descendant of the argument edge as being
       the start date of the ancestor of the argument edge
    :param edge: the edge that should be removed
    :param debug_mode: when True assume something is wrong and realize
                       additional sanity checks
    :return: True when edge removed, sys.exit() otherwise
    &#34;&#34;&#34;
    ancestor = edge.get_ancestor()
    descendant = edge.get_descendant()
    ancestor_edges = ancestor.get_ancestor_edges()

    # Rewire the ancestor_edges to the descendant
    if ancestor_edges:
        for ancestor_edge in ancestor_edges:
            ancestor_edge.set_descendant(descendant)
        # Conversely, let the descendant know about its new ancestor edges
        descendant.add_ancestor_edges(ancestor_edges)

    # Disconnect the ancestor node from all its adjacent edges
    ancestor.disconnect_adjacent_edges()

    # We must now proceed with isolating/un-connecting the edge
    self.disconnect_edge(edge)

    # Both the ancestor node and the edge to be collapsed are now isolated
    # from the graph. We can proceed with their removal:
    self.delete_node(ancestor, debug_mode)
    self.delete_edge(edge, debug_mode)

    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.delete_edge"><code class="name flex">
<span>def <span class="ident">delete_edge</span></span>(<span>self, edge, deep_assert=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert this edge has no adjacent nodes (that it knows about) and delete
it from the graph.
:param edge: the edge to be removed
:param deep_assert: when true, assert that no other node of the graph
(that the edge wouldn't know about) is pointing to
the argument edge
:return: True when properly deleted, sys.exit() otherwiwe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_edge(self, edge, deep_assert=False):
    &#34;&#34;&#34;
    Assert this edge has no adjacent nodes (that it knows about) and delete
    it from the graph.
    :param edge: the edge to be removed
    :param deep_assert: when true, assert that no other node of the graph
                        (that the edge wouldn&#39;t know about) is pointing to
                        the argument edge
    :return: True when properly deleted, sys.exit() otherwiwe
    &#34;&#34;&#34;
    if edge.get_ancestor() or edge.get_descendant():
        print(&#39;Cannot delete following edge with an ancestor or descendant&#39;)
        pprint(vars(edge))
        sys.exit()
    if deep_assert:
        for node in self.nodes:
            if edge in node.get_ancestor_edges():
                print(&#39;Cannot delete following edge:&#39;)
                pprint(vars(edge))
                print(&#39;   because it is an ancestor edge of following node:&#39;)
                pprint(vars(node))
                sys.exit()
            if edge in node.get_descendant_edges():
                print(&#39;Cannot delete following edge:&#39;)
                pprint(vars(edge))
                print(&#39;   because it is a descendant edge of following node:&#39;)
                pprint(vars(node))
                sys.exit()
    self.edges.remove(edge)
    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.delete_node"><code class="name flex">
<span>def <span class="ident">delete_node</span></span>(<span>self, node, deep_assert=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert this node has no adjacent edge that it knows about and delete
it from the graph.
:param node: the node to be removed
:param deep_assert: when true, assert that no other edge of the graph
(that the node wouldn't know about) is pointing to
the argument node
:return: True when properly deleted, sys.exit() otherwiwe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_node(self, node, deep_assert=False):
    &#34;&#34;&#34;
    Assert this node has no adjacent edge that it knows about and delete
    it from the graph.
    :param node: the node to be removed
    :param deep_assert: when true, assert that no other edge of the graph
                        (that the node wouldn&#39;t know about) is pointing to
                        the argument node
    :return: True when properly deleted, sys.exit() otherwiwe
    &#34;&#34;&#34;
    if node.get_ancestors() or node.get_descendants():
        print(&#39;Cannot delete following node with ancestors or descendants&#39;)
        pprint(vars(node))
        sys.exit()
    if deep_assert:
        for edge in self.edges:
            if edge.get_ancestor() == node or edge.get_descendant() == node:
                print(&#39;Cannot delete following node:&#39;)
                pprint(vars(node))
                print(&#39;   because it is refered by following edge:&#39;)
                pprint(vars(edge))
                sys.exit()
    if node not in self.nodes:
        print(&#39;Cannot delete following node:&#39;)
        pprint(vars(node))
        print(&#39;   because it is not in the graph nodes.&#39;)
        sys.exit()
    self.nodes.remove(node)
    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.disconnect_edge"><code class="name flex">
<span>def <span class="ident">disconnect_edge</span></span>(<span>self, edge)</span>
</code></dt>
<dd>
<div class="desc"><p>Isolate this edge from its adjacent nodes and tell those adjacent
nodes to forget about the existence of this edge. This method
is usually called prior to delete_edge.
:param edge: the edge to be disconnected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_edge(self, edge):
    &#34;&#34;&#34;
    Isolate this edge from its adjacent nodes and tell those adjacent
    nodes to forget about the existence of this edge. This method
    is usually called prior to delete_edge.
    :param edge: the edge to be disconnected.
    &#34;&#34;&#34;
    # Clean up the ancestor and descendant nodes:
    if not edge.ancestor:
        print(&#39;The following edge has no ancestor:&#39;)
        pprint(vars(edge))
        print(&#39;Exiting.&#39;)
        sys.exit(1)
    descendant_edges = edge.ancestor.get_descendant_edges()
    if edge in descendant_edges:
        descendant_edges.remove(edge)

    if not edge.descendant:
        print(&#39;The following edge has no ancestor:&#39;)
        pprint(vars(edge))
        print(&#39;Exiting.&#39;)
        sys.exit(1)
    ancestor_edges = edge.descendant.get_ancestor_edges()
    if edge in ancestor_edges:
        ancestor_edges.remove(edge)

    # We finish will un-connecting the edge per-se
    edge.set_ancestor(None)
    edge.set_descendant(None)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.display_characteristics"><code class="name flex">
<span>def <span class="ident">display_characteristics</span></span>(<span>self, indent='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_characteristics(self, indent=&#34;&#34;):
    print(indent + &#34;Nodes: total number&#34;, len(self.nodes))
    edges_number = len(self.edges)
    modified_edges_number = \
        len([e for e in self.edges if e.is_modified()])
    re_ided_edges_number = \
        len([e for e in self.edges if e.is_re_ided()])
    subdivision_edges_number = \
        len([e for e in self.edges if e.is_subdivided()])
    fusion_edges_number = \
        len([e for e in self.edges if e.is_fusion()])
    unchanged_edges_number = \
        len([e for e in self.edges if e.is_unchanged()])
    replacement_edges_number = modified_edges_number \
        + re_ided_edges_number \
        + subdivision_edges_number \
        + fusion_edges_number \
        + unchanged_edges_number

    print(indent + &#34;Edges: total number&#34;, edges_number)
    print(indent + &#34;  - modified edges: &#34;, modified_edges_number)
    print(indent + &#34;  - re-ided edges: &#34;, re_ided_edges_number)
    print(indent + &#34;  - subdivision edges: &#34;, subdivision_edges_number)
    print(indent + &#34;  - fusion edges: &#34;, fusion_edges_number)
    print(indent + &#34;  - unchanged edges: &#34;, unchanged_edges_number)
    print(indent + &#34;  - replace edges total&#34;, replacement_edges_number)
    if edges_number != replacement_edges_number:
        print(indent + &#34;WARNING: missmatching number of edges&#34;)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.extend_with_subgraph"><code class="name flex">
<span>def <span class="ident">extend_with_subgraph</span></span>(<span>self, sub_graph)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_with_subgraph(self, sub_graph):
    # Concerning the nodes of sub_graph we have two possibilities
    # - the node with corresponding globalid already exists in this
    #   graph in which case we need the edges to point to it
    # - the nodes is new (i.e. the node does not correspond to and existing
    #   node with the same globalid within this graph) and we need to
    #   pour/add in this graph

    # The dictionary having the sub_graph node index as key and this
    # graph node as value
    for node in sub_graph.nodes:
        existing_node = self.find_node_from_global_id(node.globalid)
        if existing_node:
            # We need to rewire the edges to the already existing node
            ancestor_edges = node.get_ancestor_edges()
            if ancestor_edges:
                for edge in ancestor_edges:
                    edge.set_descendant(existing_node)

            descendant_edges = node.get_descendant_edges()
            if descendant_edges:
                for edge in descendant_edges:
                    edge.set_ancestor(existing_node)

            # Keep a trace of the identification of the nodes
            existing_node.file_ids += f&#39;{node.id}, &#39;
        else:
            # No edge rewiring required. We simply need to add the
            # new sub-graph node to the this graph and change its
            # id to avoid id collisions:
            node.file_ids += f&#39;{node.id}, &#39;
            node.id = len(self.nodes) + 1
            self.nodes.append(node)

    # All sub-graph edges (rewired or not) must be kept and thus get
    # poured/blended within this graph:
    for new_edge in sub_graph.edges:
        new_edge.file_ids += f&#39;{new_edge.id}, &#39;
        new_edge.id = len(self.edges) + 1
        self.edges.append(new_edge)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_global_id"><code class="name flex">
<span>def <span class="ident">find_node_from_global_id</span></span>(<span>self, globalid)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve, when it exists, the node with the given globalid
:param globalid: the global id that is looked for
:return: the node with globalid when found, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_node_from_global_id(self, globalid):
    &#34;&#34;&#34;
    Retrieve, when it exists, the node with the given globalid
    :param globalid: the global id that is looked for
    :return: the node with globalid when found, None otherwise
    &#34;&#34;&#34;
    encountered = [node for node in self.nodes if node.globalid == globalid]
    if len(encountered) == 0:
        return None
    elif len(encountered) == 1:
        return encountered[0]
    else:
        print(f&#39;Many nodes with same globalid: {globalid}&#39;)
        pprint(vars(encountered))
        sys.exit()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.print_nodes_and_edges"><code class="name flex">
<span>def <span class="ident">print_nodes_and_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_nodes_and_edges(self):
    for node in self.nodes:
        if node.is_unknown():
            print(&#34;A node with unknown status was found:&#34;)
            pprint(vars(node))
            sys.exit(1)
        print(node)

    for edge in self.edges:
        print(edge)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Graph.split_edge_and_remove_descendant"><code class="name flex">
<span>def <span class="ident">split_edge_and_remove_descendant</span></span>(<span>self, edge, debug_mode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Split the given edge that is
- take all the descendant edges of the descendant of the argument edge
and make them descendant edges of the ancestor of that argument edge
- remove the argument edge from the list of descendant_edges (of
the ancestor for the argument edge)
- remove the argument edge from the graph
- set the start date of the descendants of the descendant of argument
edge as being the start date of the descendant of the argument edge
:param edge: the edge that should split (and technically removed)
:param debug_mode: when True assume something is wrong and realize
additional sanity checks
:return: True when edge removed, sys.exit() otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_edge_and_remove_descendant(self, edge, debug_mode=False):
    &#34;&#34;&#34;
    Split the given edge that is
     - take all the descendant edges of the descendant of the argument edge
       and make them descendant edges of the ancestor of that argument edge
     - remove the argument edge from the list of descendant_edges (of
       the ancestor for the argument edge)
     - remove the argument edge from the graph
     - set the start date of the descendants of the descendant of argument
       edge as being the start date of the descendant of the argument edge
    :param edge: the edge that should split (and technically removed)
    :param debug_mode: when True assume something is wrong and realize
                       additional sanity checks
    :return: True when edge removed, sys.exit() otherwise
    &#34;&#34;&#34;

    ancestor = edge.get_ancestor()
    descendant = edge.get_descendant()
    descendant_edges = descendant.get_descendant_edges()

    # Rewire the ancestor of descendant_edges (of the descendant) to
    # being the ancestor
    if descendant_edges:
        for descendant_edge in descendant_edges:
            descendant_edge.set_ancestor(ancestor)
        # Conversely, let the ancestor node know it has new descendant
        # edges (acting as the split versions of the argument edge)
        ancestor.add_descendant_edge(descendant_edge)

    # Disconnect the descendant node from all its adjacent edges
    descendant.disconnect_adjacent_edges()

    # We must now proceed with isolating/un-connecting the edge
    self.disconnect_edge(edge)

    # Both the descendant node and the edge to be collapsed are now isolated
    # from the graph. We can proceed with their removal:
    self.delete_node(descendant, debug_mode)
    self.delete_edge(edge, debug_mode)

    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.GraphMLDecoder"><code class="flex name class">
<span>class <span class="ident">GraphMLDecoder</span></span>
</code></dt>
<dd>
<div class="desc"><p>Simple JSON <a href="http://json.org">http://json.org</a> decoder</p>
<p>Performs the following translations in decoding by default:</p>
<p>+---------------+-------------------+
| JSON
| Python
|
+===============+===================+
| object
| dict
|
+---------------+-------------------+
| array
| list
|
+---------------+-------------------+
| string
| str
|
+---------------+-------------------+
| number (int)
| int
|
+---------------+-------------------+
| number (real) | float
|
+---------------+-------------------+
| true
| True
|
+---------------+-------------------+
| false
| False
|
+---------------+-------------------+
| null
| None
|
+---------------+-------------------+</p>
<p>It also understands <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> as
their corresponding <code>float</code> values, which is outside the JSON spec.</p>
<p><code>object_hook</code>, if specified, will be called with the result
of every JSON object decoded and its return value will be used in
place of the given <code>dict</code>.
This can be used to provide custom
deserializations (e.g. to support JSON-RPC class hinting).</p>
<p><code>object_pairs_hook</code>, if specified will be called with the result of
every JSON object decoded with an ordered list of pairs.
The return
value of <code>object_pairs_hook</code> will be used instead of the <code>dict</code>.
This feature can be used to implement custom decoders.
If <code>object_hook</code> is also defined, the <code>object_pairs_hook</code> takes
priority.</p>
<p><code>parse_float</code>, if specified, will be called with the string
of every JSON float to be decoded. By default this is equivalent to
float(num_str). This can be used to use another datatype or parser
for JSON floats (e.g. decimal.Decimal).</p>
<p><code>parse_int</code>, if specified, will be called with the string
of every JSON int to be decoded. By default this is equivalent to
int(num_str). This can be used to use another datatype or parser
for JSON integers (e.g. float).</p>
<p><code>parse_constant</code>, if specified, will be called with one of the
following strings: -Infinity, Infinity, NaN.
This can be used to raise an exception if invalid JSON numbers
are encountered.</p>
<p>If <code>strict</code> is false (true is the default), then control
characters will be allowed inside strings.
Control characters in
this context are those with character codes in the 0-31 range,
including <code>'\t'</code> (tab), <code>'\n'</code>, <code>'\r'</code> and <code>'\0'</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphMLDecoder(json.JSONDecoder):
    def __init__(self):
        json.JSONDecoder.__init__(self, object_hook=self.dict_to_object)

    def dict_to_object(self, dct):
        if &#39;id&#39; in dct and &#39;globalid&#39; in dct:
            return Node(**dct)
        if &#39;id&#39; in dct \
                and &#39;source&#39; in dct \
                and &#39;target&#39; in dct \
                and &#39;type&#39; in dct \
                and &#39;tags&#39; in dct:
            edge = Edge(**dct)
            # Because the Json deserializer will make edge.tags a string
            # (as opposed to a list), and because we found it messy to
            # fix that in the Edge constructor, we &#34;fix&#34; things here.
            # That is we manually convert the tags value that was set
            # (as a string) into a list with and Edge.Tag
            if edge.tags == &#39;re-ided&#39;:
                # This is special case is due to the fact that an enum
                # name of re-ided is not possible (is in interpreted as
                # a minus operation (between re and ided) in the definition
                # of the enum
                edge.set_tag_from_string(&#39;re_ided&#39;)
            else:
                edge.set_tag_from_string(edge.tags)
            return edge
        return dct</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.decoder.JSONDecoder</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.GraphMLDecoder.dict_to_object"><code class="name flex">
<span>def <span class="ident">dict_to_object</span></span>(<span>self, dct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict_to_object(self, dct):
    if &#39;id&#39; in dct and &#39;globalid&#39; in dct:
        return Node(**dct)
    if &#39;id&#39; in dct \
            and &#39;source&#39; in dct \
            and &#39;target&#39; in dct \
            and &#39;type&#39; in dct \
            and &#39;tags&#39; in dct:
        edge = Edge(**dct)
        # Because the Json deserializer will make edge.tags a string
        # (as opposed to a list), and because we found it messy to
        # fix that in the Edge constructor, we &#34;fix&#34; things here.
        # That is we manually convert the tags value that was set
        # (as a string) into a list with and Edge.Tag
        if edge.tags == &#39;re-ided&#39;:
            # This is special case is due to the fact that an enum
            # name of re-ided is not possible (is in interpreted as
            # a minus operation (between re and ided) in the definition
            # of the enum
            edge.set_tag_from_string(&#39;re_ided&#39;)
        else:
            edge.set_tag_from_string(edge.tags)
        return edge
    return dct</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(object):
    @unique
    class Status(Enum):
        &#34;&#34;&#34;
        Historical status of the node (mainly used on documentation/debug
        purposes) indicating the nature of the node in its relationship
        with past and future nodes
        &#34;&#34;&#34;
        unknown = 1
        # Appears isolated at a single time stamp (neither ancestors nor
        # descendants)
        hapax = 2
        # Beginning of a lineage of nodes (no ancestors)
        start = 3
        # Termination of a lineage of nodes (no descendants)
        end = 4
        # Historical link/connection between the past nodes and future nodes
        # (has both ancestors and descendants)
        link = 5

    def __init__(self, **kwargs):
        # Attributes that will be dynamically added by the Json parsing
        # An integer used as Node identifier (local to a single Graph file)
        self.id = None
        # A string used as (global) Node identifier i.e. valid across a
        # set of Graph files
        self.globalid = None
        self.__dict__ = kwargs

        # When blending various graphs (respectively loaded from different
        # graph files), the nodes shared among such graphs (as designated
        # with their globalid) need to be reconciled. For some nodes (
        # (e.g. for nodes that are loaded when a previous node with
        # the same globalid already existed) the self.id (relative to a
        # file) will thus be lost. In order to help traceability (read
        # debugging) of the nodes, we keep the original file identifiers
        # in the following attribute:
        self.file_ids = &#39;&#39;

        self.start_date = None
        self.end_date = None

        # Design note: we had the choice to either store the ancestor nodes
        # or to store the &#34;ancestor edges&#34; (that is edges that have this
        # node as target). Both choices have their respective drawbacks.
        # When storing the nodes and we need the information attached to
        # the edges we need to retrieve those edges (and the cost of retrieving
        # an edge out of its adjacent vertices is not constant in graph size).
        # And when storing the edges, retrieving the ancestors requires a
        # (constant time) walk on those edges.
        # Note that storing both is always risky because we must keep them
        # &#34;aligned&#34; (in sync).
        # We chose to store edges to keep the computation complexity constant.
        # The list of edges that have this node as target:
        self.ancestor_edges = list()

        # A list of edges which have this node a source. The targets of those
        # edges are thus nodes that come after in time which make them
        # descendants:
        self.descendant_edges = list()

        self.status = Node.Status.unknown
        self.set_hapax(self.get_time_stamp())

    def __str__(self):
        ret_str = f&#39;Node: {self.globalid} (id: {self.id})\n&#39;
        ret_str += f&#39;  Starting date: {self.start_date} \n&#39;
        ret_str += f&#39;  Ending date: {self.end_date} \n&#39;
        ret_str += f&#39;  Status: {self.status} \n&#39;
        if self.ancestor_edges:
            ret_str += &#39;  Ancestors: &#39;
            for ancestor in self.get_ancestors():
                ret_str += ancestor.globalid + &#39;, &#39;
            ret_str += &#39;\n&#39;
        if self.descendant_edges:
            ret_str += &#39;  Descendants: &#39;
            for descendant in self.get_descendants():
                ret_str += descendant.globalid + &#39;, &#39;
            ret_str += &#39;\n&#39;
        if self.file_ids != &#39;&#39;:
            ret_str += f&#39;  file_ids: {self.file_ids}\n&#39;
        return ret_str

    def is_unknown(self):
        if self.status == Node.Status.unknown:
            return True
        return False

    def is_hapax(self):
        if self.status == Node.Status.hapax:
            return True
        return False

    def is_start(self):
        if self.status == Node.Status.start:
            return True
        return False

    def is_end(self):
        if self.status == Node.Status.end:
            return True
        return False

    def is_link(self):
        if self.status == Node.Status.link:
            return True
        return False

    def assert_status_coherence(self):
        ancestors = self.get_ancestors()
        descendants = self.get_descendants()
        if not ancestors and not descendants:
            if self.is_unknown():
                # No information and nothing to assert
                return
            if self.is_hapax():
                # A hapax indeed has not ancestors nor descendants
                return
            else:
                print(&#34;Only a hapax has neither ancestors nor descendants.&#34;)
                sys.exit(1)
        if ancestors and not descendants:
            if self.is_unknown():
                print(&#34;Should have been an end prior to having ancestors.&#34;)
                sys.exit(1)
            return
        if not ancestors and descendants:
            if self.is_unknown():
                print(&#34;Should have been a start prior to having descendants.&#34;)
                sys.exit(1)
            return
        # The Node has both ancestors and descendants:
        if self.is_unknown():
            print(&#34;Should have been a hapax, a start or end prior to having&#34;)
            print(&#34;both ancestors and descendants.&#34;)
            sys.exit(1)
        if not self.is_link():
            print(&#34;This node has both ancestors and descendants but is not&#34;)
            print(&#34;a link but a: &#34;, self.status)
            sys.exit(1)

    def are_all_ancestor_edges_of_type(self, edge_type):
        &#34;&#34;&#34;
        :return: True when they are at least two ancestor edges and all
                 ancestor edges are of the provided parameter (edge) type.
                 False otherwise.
        &#34;&#34;&#34;
        ancestor_edges = self.get_ancestor_edges()
        if len(ancestor_edges) &lt; 2:
            # We need at least two edges for them to be the same
            return False
        for edge in ancestor_edges:
            if not edge.is_of_type(edge_type):
                return False
        return True

    def are_all_descendant_edges_of_type(self, edge_type):
        &#34;&#34;&#34;
        :return: True when they are at least two descendant edges and all
                 descendant edges are subdivision edges. False otherwise.
        &#34;&#34;&#34;
        descendant_edges = self.get_descendant_edges()
        if len(descendant_edges) &lt; 2:
            # We need at least two edges for them to be the same
            return False
        for edge in descendant_edges:
            if not edge.is_of_type(edge_type):
                return False
        return True

    def do_all_ancestor_nodes_share_same_date(self):
        &#34;&#34;&#34;
        :return: True when they are at least two ancestor nodes and all
                 such ancestor nodes have exactly the same creation and
                 deletiondates. False otherwise.
        &#34;&#34;&#34;
        ancestors = self.get_ancestors()
        if len(ancestors) &lt; 2:
            # We need at least two ancestors for them to have matching dates
            return False
        start_date = ancestors[0].get_start_date()
        end_date = ancestors[0].get_end_date()
        for ancestor in ancestors[1:]:
            if not ancestor.get_start_date() == start_date:
                return False
            if not ancestor.get_end_date() == end_date:
                return False
        return True

    def do_all_descendant_nodes_share_same_date(self):
        &#34;&#34;&#34;
        :return: True when they are at least two descendant nodes and all
                 such descendant nodes have exactly the same creation and
                 deletiondates. False otherwise.
        &#34;&#34;&#34;
        descendants = self.get_descendants()
        if len(descendants) &lt; 2:
            # We need at least two descendants for them to have matching dates
            return False
        start_date = descendants[0].get_start_date()
        end_date = descendants[0].get_end_date()
        for descendant in descendants[1:]:
            if not descendant.get_start_date() == start_date:
                return False
            if not descendant.get_end_date() == end_date:
                return False
        return True

    def get_time_stamp(self):
        return int(self.globalid.split(&#39;::&#39;)[0])

    def get_local_id(self):
        return self.globalid.split(&#39;::&#39;)[1]

    def get_global_id(self):
        return self.globalid

    def get_end_date(self):
        return self.end_date

    def set_end_date(self, time_stamp):
        self.end_date = time_stamp

    def get_start_date(self):
        return self.start_date

    def set_start_date(self, time_stamp):
        self.start_date = time_stamp

    def set_creation_date_if_earlier(self, time_stamp):
        &#34;&#34;&#34;
        When the given time_stamp is earlier than the current value of
        the node start_date then set the start_date with that value
        :param time_stamp: the time stamp that should be set when it is earlier
        :return: None
        &#34;&#34;&#34;
        if not self.start_date:
            self.start_date = time_stamp
            return
        if time_stamp &lt; self.start_date:
            self.start_date = time_stamp

    def set_creation_date_recursive(self, time_stamp):
        self.set_creation_date_if_earlier(time_stamp)
        for descendant in self.get_descendants():
            descendant.set_creation_date_recursive(time_stamp)

    def set_deletion_date_if_later(self, time_stamp):
        if not self.end_date:
            self.end_date = time_stamp
            return
        if time_stamp &gt; self.end_date:
            self.end_date = time_stamp

    def get_ancestors(self):
        return [edge.ancestor for edge in self.ancestor_edges]

    def add_ancestor_edge(self, ancestor_edge):
        if not ancestor_edge:
            return
        self.ancestor_edges.append(ancestor_edge)
        if self.is_hapax():
            self.set_end()
        elif self.is_start():
            self.set_link()

    def add_ancestor_edges(self, ancestor_edges_list):
        for edge in ancestor_edges_list:
            self.add_ancestor_edge(edge)

    def get_ancestor_edges(self):
        return self.ancestor_edges

    def get_descendants(self):
        &#34;&#34;&#34;
        :return: the list of the direct descendants (no recursion done)
        &#34;&#34;&#34;
        return [edge.descendant for edge in self.descendant_edges]

    def add_descendant_edge(self, descendant_edge, debug_mode=False):
        if not descendant_edge:
            return
        if debug_mode and descendant_edge in self.descendant_edges:
            print(&#34;The following edge: &#34;)
            pprint(vars(descendant_edge))
            print(&#34;is already part of the descendant edges of this node: &#34;)
            pprint(vars(self))
            print(&#39;Exiting.&#39;)
            sys.exit(1)
        self.descendant_edges.append(descendant_edge)
        if self.is_hapax():
            self.set_start()
        elif self.is_end():
            self.set_link()

    def add_descendant_edges(self, descendant_edge_list):
        for edge in descendant_edge_list:
            self.add_descendant_edge(edge)

    def get_descendant_edges(self):
        return self.descendant_edges

    def reset_descendant_edges(self):
        self.descendant_edges = list()

    def disconnect_adjacent_edges(self):
        self.ancestor_edges = list()
        self.reset_descendant_edges()

    def set_hapax(self, time_stamp):
        if not self.is_unknown():
            print(&#34;Failing to promote as hapax from status: &#34;, self.status)
            sys.exit(1)
        self.status = Node.Status.hapax
        if self.start_date:
            print(&#34;This newly converted hapax already had a start_date.&#34;)
            sys.exit(1)
        self.start_date = time_stamp
        if self.end_date:
            print(&#34;This newly converted hapax already had a end_date.&#34;)
            sys.exit(1)
        self.end_date = time_stamp
        self.assert_status_coherence()

    def set_start(self, time_stamp=None):
        if not self.is_unknown() and not self.is_hapax():
            print(&#34;Failed to define as start.&#34;)
            sys.exit(1)
        if self.is_end():
            print(&#34;Failed to convert an end into being a start.&#34;)
            sys.exit(1)
        if self.is_link():
            print(&#34;Failed to convert a link into being a start.&#34;)
            sys.exit(1)
        self.status = Node.Status.start
        if time_stamp:
            if self.start_date:
                print(&#34;Warning: overwriting a start_date of a new start.&#34;)
            self.start_date = time_stamp
        self.assert_status_coherence()

    def set_end(self, time_stamp=None):
        if not self.is_unknown() and not self.is_hapax():
            print(&#34;Failed to define as end.&#34;)
            sys.exit(1)
        if self.is_start():
            print(&#34;Failed to convert a start into being a end.&#34;)
            sys.exit(1)
        if self.is_link():
            print(&#34;Failed to convert a link into being an end.&#34;)
            sys.exit(1)
        self.status = Node.Status.end
        if time_stamp:
            if self.end_date:
                print(&#34;Warning: overwriting a start_date of a new end.&#34;)
            self.end_date = time_stamp
        self.assert_status_coherence()

    def set_link(self):
        if self.is_unknown():
            print(&#34;An unknown node should not be converted to being an link.&#34;)
            sys.exit(1)
        if self.is_hapax():
            print(&#34;An hapax node should not be converted to being an link.&#34;)
            sys.exit(1)
        self.status = Node.Status.link</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.Status"><code class="name">var <span class="ident">Status</span></code></dt>
<dd>
<div class="desc"><p>Historical status of the node (mainly used on documentation/debug
purposes) indicating the nature of the node in its relationship
with past and future nodes</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.add_ancestor_edge"><code class="name flex">
<span>def <span class="ident">add_ancestor_edge</span></span>(<span>self, ancestor_edge)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ancestor_edge(self, ancestor_edge):
    if not ancestor_edge:
        return
    self.ancestor_edges.append(ancestor_edge)
    if self.is_hapax():
        self.set_end()
    elif self.is_start():
        self.set_link()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.add_ancestor_edges"><code class="name flex">
<span>def <span class="ident">add_ancestor_edges</span></span>(<span>self, ancestor_edges_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ancestor_edges(self, ancestor_edges_list):
    for edge in ancestor_edges_list:
        self.add_ancestor_edge(edge)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.add_descendant_edge"><code class="name flex">
<span>def <span class="ident">add_descendant_edge</span></span>(<span>self, descendant_edge, debug_mode=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_descendant_edge(self, descendant_edge, debug_mode=False):
    if not descendant_edge:
        return
    if debug_mode and descendant_edge in self.descendant_edges:
        print(&#34;The following edge: &#34;)
        pprint(vars(descendant_edge))
        print(&#34;is already part of the descendant edges of this node: &#34;)
        pprint(vars(self))
        print(&#39;Exiting.&#39;)
        sys.exit(1)
    self.descendant_edges.append(descendant_edge)
    if self.is_hapax():
        self.set_start()
    elif self.is_end():
        self.set_link()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.add_descendant_edges"><code class="name flex">
<span>def <span class="ident">add_descendant_edges</span></span>(<span>self, descendant_edge_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_descendant_edges(self, descendant_edge_list):
    for edge in descendant_edge_list:
        self.add_descendant_edge(edge)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.are_all_ancestor_edges_of_type"><code class="name flex">
<span>def <span class="ident">are_all_ancestor_edges_of_type</span></span>(<span>self, edge_type)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True when they are at least two ancestor edges and all
ancestor edges are of the provided parameter (edge) type.
False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def are_all_ancestor_edges_of_type(self, edge_type):
    &#34;&#34;&#34;
    :return: True when they are at least two ancestor edges and all
             ancestor edges are of the provided parameter (edge) type.
             False otherwise.
    &#34;&#34;&#34;
    ancestor_edges = self.get_ancestor_edges()
    if len(ancestor_edges) &lt; 2:
        # We need at least two edges for them to be the same
        return False
    for edge in ancestor_edges:
        if not edge.is_of_type(edge_type):
            return False
    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.are_all_descendant_edges_of_type"><code class="name flex">
<span>def <span class="ident">are_all_descendant_edges_of_type</span></span>(<span>self, edge_type)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True when they are at least two descendant edges and all
descendant edges are subdivision edges. False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def are_all_descendant_edges_of_type(self, edge_type):
    &#34;&#34;&#34;
    :return: True when they are at least two descendant edges and all
             descendant edges are subdivision edges. False otherwise.
    &#34;&#34;&#34;
    descendant_edges = self.get_descendant_edges()
    if len(descendant_edges) &lt; 2:
        # We need at least two edges for them to be the same
        return False
    for edge in descendant_edges:
        if not edge.is_of_type(edge_type):
            return False
    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.assert_status_coherence"><code class="name flex">
<span>def <span class="ident">assert_status_coherence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_status_coherence(self):
    ancestors = self.get_ancestors()
    descendants = self.get_descendants()
    if not ancestors and not descendants:
        if self.is_unknown():
            # No information and nothing to assert
            return
        if self.is_hapax():
            # A hapax indeed has not ancestors nor descendants
            return
        else:
            print(&#34;Only a hapax has neither ancestors nor descendants.&#34;)
            sys.exit(1)
    if ancestors and not descendants:
        if self.is_unknown():
            print(&#34;Should have been an end prior to having ancestors.&#34;)
            sys.exit(1)
        return
    if not ancestors and descendants:
        if self.is_unknown():
            print(&#34;Should have been a start prior to having descendants.&#34;)
            sys.exit(1)
        return
    # The Node has both ancestors and descendants:
    if self.is_unknown():
        print(&#34;Should have been a hapax, a start or end prior to having&#34;)
        print(&#34;both ancestors and descendants.&#34;)
        sys.exit(1)
    if not self.is_link():
        print(&#34;This node has both ancestors and descendants but is not&#34;)
        print(&#34;a link but a: &#34;, self.status)
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.disconnect_adjacent_edges"><code class="name flex">
<span>def <span class="ident">disconnect_adjacent_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect_adjacent_edges(self):
    self.ancestor_edges = list()
    self.reset_descendant_edges()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.do_all_ancestor_nodes_share_same_date"><code class="name flex">
<span>def <span class="ident">do_all_ancestor_nodes_share_same_date</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True when they are at least two ancestor nodes and all
such ancestor nodes have exactly the same creation and
deletiondates. False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_all_ancestor_nodes_share_same_date(self):
    &#34;&#34;&#34;
    :return: True when they are at least two ancestor nodes and all
             such ancestor nodes have exactly the same creation and
             deletiondates. False otherwise.
    &#34;&#34;&#34;
    ancestors = self.get_ancestors()
    if len(ancestors) &lt; 2:
        # We need at least two ancestors for them to have matching dates
        return False
    start_date = ancestors[0].get_start_date()
    end_date = ancestors[0].get_end_date()
    for ancestor in ancestors[1:]:
        if not ancestor.get_start_date() == start_date:
            return False
        if not ancestor.get_end_date() == end_date:
            return False
    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.do_all_descendant_nodes_share_same_date"><code class="name flex">
<span>def <span class="ident">do_all_descendant_nodes_share_same_date</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True when they are at least two descendant nodes and all
such descendant nodes have exactly the same creation and
deletiondates. False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_all_descendant_nodes_share_same_date(self):
    &#34;&#34;&#34;
    :return: True when they are at least two descendant nodes and all
             such descendant nodes have exactly the same creation and
             deletiondates. False otherwise.
    &#34;&#34;&#34;
    descendants = self.get_descendants()
    if len(descendants) &lt; 2:
        # We need at least two descendants for them to have matching dates
        return False
    start_date = descendants[0].get_start_date()
    end_date = descendants[0].get_end_date()
    for descendant in descendants[1:]:
        if not descendant.get_start_date() == start_date:
            return False
        if not descendant.get_end_date() == end_date:
            return False
    return True</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_ancestor_edges"><code class="name flex">
<span>def <span class="ident">get_ancestor_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ancestor_edges(self):
    return self.ancestor_edges</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_ancestors"><code class="name flex">
<span>def <span class="ident">get_ancestors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ancestors(self):
    return [edge.ancestor for edge in self.ancestor_edges]</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_descendant_edges"><code class="name flex">
<span>def <span class="ident">get_descendant_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_descendant_edges(self):
    return self.descendant_edges</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_descendants"><code class="name flex">
<span>def <span class="ident">get_descendants</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the list of the direct descendants (no recursion done)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_descendants(self):
    &#34;&#34;&#34;
    :return: the list of the direct descendants (no recursion done)
    &#34;&#34;&#34;
    return [edge.descendant for edge in self.descendant_edges]</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_end_date"><code class="name flex">
<span>def <span class="ident">get_end_date</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_date(self):
    return self.end_date</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_global_id"><code class="name flex">
<span>def <span class="ident">get_global_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_id(self):
    return self.globalid</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_local_id"><code class="name flex">
<span>def <span class="ident">get_local_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_local_id(self):
    return self.globalid.split(&#39;::&#39;)[1]</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_start_date"><code class="name flex">
<span>def <span class="ident">get_start_date</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_start_date(self):
    return self.start_date</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.get_time_stamp"><code class="name flex">
<span>def <span class="ident">get_time_stamp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_stamp(self):
    return int(self.globalid.split(&#39;::&#39;)[0])</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.is_end"><code class="name flex">
<span>def <span class="ident">is_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_end(self):
    if self.status == Node.Status.end:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.is_hapax"><code class="name flex">
<span>def <span class="ident">is_hapax</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_hapax(self):
    if self.status == Node.Status.hapax:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.is_link"><code class="name flex">
<span>def <span class="ident">is_link</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_link(self):
    if self.status == Node.Status.link:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.is_start"><code class="name flex">
<span>def <span class="ident">is_start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_start(self):
    if self.status == Node.Status.start:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.is_unknown"><code class="name flex">
<span>def <span class="ident">is_unknown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_unknown(self):
    if self.status == Node.Status.unknown:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.reset_descendant_edges"><code class="name flex">
<span>def <span class="ident">reset_descendant_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_descendant_edges(self):
    self.descendant_edges = list()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_creation_date_if_earlier"><code class="name flex">
<span>def <span class="ident">set_creation_date_if_earlier</span></span>(<span>self, time_stamp)</span>
</code></dt>
<dd>
<div class="desc"><p>When the given time_stamp is earlier than the current value of
the node start_date then set the start_date with that value
:param time_stamp: the time stamp that should be set when it is earlier
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creation_date_if_earlier(self, time_stamp):
    &#34;&#34;&#34;
    When the given time_stamp is earlier than the current value of
    the node start_date then set the start_date with that value
    :param time_stamp: the time stamp that should be set when it is earlier
    :return: None
    &#34;&#34;&#34;
    if not self.start_date:
        self.start_date = time_stamp
        return
    if time_stamp &lt; self.start_date:
        self.start_date = time_stamp</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_creation_date_recursive"><code class="name flex">
<span>def <span class="ident">set_creation_date_recursive</span></span>(<span>self, time_stamp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creation_date_recursive(self, time_stamp):
    self.set_creation_date_if_earlier(time_stamp)
    for descendant in self.get_descendants():
        descendant.set_creation_date_recursive(time_stamp)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_deletion_date_if_later"><code class="name flex">
<span>def <span class="ident">set_deletion_date_if_later</span></span>(<span>self, time_stamp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_deletion_date_if_later(self, time_stamp):
    if not self.end_date:
        self.end_date = time_stamp
        return
    if time_stamp &gt; self.end_date:
        self.end_date = time_stamp</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_end"><code class="name flex">
<span>def <span class="ident">set_end</span></span>(<span>self, time_stamp=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_end(self, time_stamp=None):
    if not self.is_unknown() and not self.is_hapax():
        print(&#34;Failed to define as end.&#34;)
        sys.exit(1)
    if self.is_start():
        print(&#34;Failed to convert a start into being a end.&#34;)
        sys.exit(1)
    if self.is_link():
        print(&#34;Failed to convert a link into being an end.&#34;)
        sys.exit(1)
    self.status = Node.Status.end
    if time_stamp:
        if self.end_date:
            print(&#34;Warning: overwriting a start_date of a new end.&#34;)
        self.end_date = time_stamp
    self.assert_status_coherence()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_end_date"><code class="name flex">
<span>def <span class="ident">set_end_date</span></span>(<span>self, time_stamp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_end_date(self, time_stamp):
    self.end_date = time_stamp</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_hapax"><code class="name flex">
<span>def <span class="ident">set_hapax</span></span>(<span>self, time_stamp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_hapax(self, time_stamp):
    if not self.is_unknown():
        print(&#34;Failing to promote as hapax from status: &#34;, self.status)
        sys.exit(1)
    self.status = Node.Status.hapax
    if self.start_date:
        print(&#34;This newly converted hapax already had a start_date.&#34;)
        sys.exit(1)
    self.start_date = time_stamp
    if self.end_date:
        print(&#34;This newly converted hapax already had a end_date.&#34;)
        sys.exit(1)
    self.end_date = time_stamp
    self.assert_status_coherence()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_link"><code class="name flex">
<span>def <span class="ident">set_link</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_link(self):
    if self.is_unknown():
        print(&#34;An unknown node should not be converted to being an link.&#34;)
        sys.exit(1)
    if self.is_hapax():
        print(&#34;An hapax node should not be converted to being an link.&#34;)
        sys.exit(1)
    self.status = Node.Status.link</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_start"><code class="name flex">
<span>def <span class="ident">set_start</span></span>(<span>self, time_stamp=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_start(self, time_stamp=None):
    if not self.is_unknown() and not self.is_hapax():
        print(&#34;Failed to define as start.&#34;)
        sys.exit(1)
    if self.is_end():
        print(&#34;Failed to convert an end into being a start.&#34;)
        sys.exit(1)
    if self.is_link():
        print(&#34;Failed to convert a link into being a start.&#34;)
        sys.exit(1)
    self.status = Node.Status.start
    if time_stamp:
        if self.start_date:
            print(&#34;Warning: overwriting a start_date of a new start.&#34;)
        self.start_date = time_stamp
    self.assert_status_coherence()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.Node.set_start_date"><code class="name flex">
<span>def <span class="ident">set_start_date</span></span>(<span>self, time_stamp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_start_date(self, time_stamp):
    self.start_date = time_stamp</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.TemporalGraph"><code class="flex name class">
<span>class <span class="ident">TemporalGraph</span></span>
<span>(</span><span>cli_args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TemporalGraph(Graph):

    def __init__(self, cli_args):
        Graph.__init__(self)
        self.cli_args = cli_args

    def extract_time_stamps(self):
        &#34;&#34;&#34;
        :return: the ordered (from oldest to most recent) list of time stamps
                 as extracted from the node&#39;s global identifiers.
        &#34;&#34;&#34;
        time_stamps_set = set()
        for node in self.nodes:
            time_stamps_set.add(node.get_time_stamp())
        time_stamps = list(time_stamps_set)
        time_stamps.sort()
        return time_stamps

    def get_nodes_with_time_stamp(self, time_stamp):
        if isinstance(time_stamp, str):
            time_stamp = int(time_stamp)
        return [n for n in self.nodes if n.get_time_stamp() == time_stamp]

    def reconstruct_connectivity(self):
        debug_msg(&#34;Reconstructing graph: &#34;)
        debug_msg(&#34;   Loading nodes and edges of files: &#34;)
        # Deserialize the temporal (sub) graphs to constitute the general graph
        for temporal_graph_filename in self.cli_args.temporal_graph:
            with open(temporal_graph_filename, &#39;r&#39;) as temporal_graph_file:
                temporal_graph = json.loads(temporal_graph_file.read(),
                                            cls=GraphMLDecoder)

            current_nodes = temporal_graph[&#39;nodes&#39;]
            # Because the Json GraphML we parse is produced with boost::ptree&#39;s
            # write_json method that is well known for not conforming to Json
            # (integers are serialized as strings i.e. enclosed with double quotes)
            # we need to &#34;fix&#34; things after the Json parser is run
            for node in current_nodes:
                if isinstance(node.id, str):
                    node.id = int(node.id)

            current_edges = temporal_graph[&#39;edges&#39;]
            # Edges id must also be type fixed (refer above to current_nodes)
            for edge in current_edges:
                if isinstance(edge.id, str):
                    edge.id = int(edge.id)

            # Additionally we need to replace the node indexes (integer) loaded
            # as source and target (with the Json type fix) to their corresponding
            # references (as python objects):
            for edge in current_edges:
                if isinstance(edge.source, str):
                    edge.set_ancestor(Graph.find_node_from_id(
                        current_nodes, int(edge.source)))
                if isinstance(edge.target, str):
                    edge.set_descendant(Graph.find_node_from_id(
                        current_nodes, int(edge.target)))

            # Eventually we can append the current graph:
            if not self.nodes:
                Graph.__init__(self, current_nodes, current_edges)
            else:
                self.extend_with_subgraph(Graph(current_nodes, current_edges))
            debug_msg(&#34;   &#34; + str(temporal_graph_filename) + &#34;: done.&#34;)
        debug_msg(&#34;  Loading of files: done.&#34;)
        debug_msg(&#34;Graph reconstruction: done.&#34;)

    def remove_replicate_descendant_edges(self, node):
        &#34;&#34;&#34;
        When two nodes have multiple adjacent edges (that there exists at least
        two edges that are adjacent to same two nodes) then wish to remove the
        replicates in order to leave a single edge.
        This method considers all the descendant edges of the provided
        argument node, looks for replicates and removes them.
        :param node: the considered node
        :return: the number of edges that were removed
        &#34;&#34;&#34;
        number_removed_edges = 0
        seen_node = set()
        for descendant_edge in node.get_descendant_edges():
            descendant = descendant_edge.get_descendant()
            descendant_id = descendant.get_global_id()
            if descendant_id in seen_node:
                # This is a replicate edge that we trash.
                self.disconnect_edge(descendant_edge)
                # Note that we don&#39;t need to inspect for other nodes &#34;knowing&#34;
                # (refering to) that edge because we knew both its endpoints
                # that disconnecting the edge got those nodes informed
                self.delete_edge(descendant_edge, False)
                number_removed_edges += 1
            else:
                seen_node.add(descendant_id)
        return number_removed_edges

    def simplify(self, display_characteristics=False):
        debug_msg(&#34;Simplifying the graph:&#34;)
        # At this point we have lineage information at hand in the form of the
        # reconstructed graph. We still have to simplify that graph in order
        # to re-interpret the available lineages at the level of the objects
        # (the buildings in this application). For example if the building B_1 is
        # present for year Y1, Y2 and Y3 and the land-print (geometry) of the
        # building remains unchanged during those years (same geometry) then
        # we can abstract such a situation by stating (in a 3DTiles temporal
        # framework) that building B_1 has a creation date of Y1 and a deletion
        # date of Y3. In other terms we simplified the sub-graph
        #                 unchanged               unchanged
        #     [B_1, Y1] ------------&gt; [B_1, Y2] -------------&gt; [B_1, Y3]
        # to be reduced to a single node/vertex
        #                           [B_1, Y1-Y3]
        # For more complicated cases (e.g. when the geometry gets modified), the
        # simplified graph will still posses edges that will need to be
        # represented (within the resulting tileset) as (3DTiles) temporal
        # transactions.
        #
        # In the following simplification process note that we iterate over
        # the time stamps in order to apply some graph simplification (empirical)
        # rules. When doing so we start from the past (oldest time stamps) and
        # proceed towards the future (the most recent time stamps). The reason
        # for this past to future time oriented sweeping process (as opposed to
        # random order or from future to past) is to obtain a simplified graph
        # that keeps the most recent building geometries (and removes the oldest
        # nodes i.e. the most ancient building geometries). The assumption behind
        # such time stamp sweeping strategy is that most recent city descriptions
        # are also the most detailed.

        time_stamps = self.extract_time_stamps()

        debug_msg(&#34;  Stage 0: removing duplicate edges.&#34;)
        duplicates = 0
        for time_stamp in time_stamps:
            current_nodes = self.get_nodes_with_time_stamp(time_stamp)
            for node in current_nodes:
                duplicates += self.remove_replicate_descendant_edges(node)
        if duplicates:
            debug_msg(f&#39;    Number of removed duplicates edges: {duplicates}&#39;)
        else:
            debug_msg(&#39;    No duplicates edges found.&#39;)

        # Note that the relative order of application of the following
        # simplification strategies (labeled as stages) does matter. In particular
        #  - collapsing unchanged/re-ided 1 to 1 edges should NOT be realized
        #    prior to collapsing fusion edges, but
        #  - collapsing unchanged/re-ided 1 to 1 edges MUST be realized prior to
        #    collapsing subdivision edges
        # The above constraints on relative order leave a single ordering
        # possibility that is thus used below.

        debug_msg(&#34;  Stage 1: collapsing unchanged/re-ided 1 to 1 edges.&#34;)
        initial_number_one_to_one_edges = \
            len([e for e in self.edges if e.are_adjacent_nodes_one_to_one() and (e.is_unchanged() or e.is_re_ided())])
        one_to_one_number = 0
        to_remove = self.edges.copy()
        for edge in to_remove:
            if not edge.are_adjacent_nodes_one_to_one():
                continue
            if edge.is_unchanged() or edge.is_re_ided():
                ancestor = edge.get_ancestor()
                descendant = edge.get_descendant()
                descendant.set_start_date(ancestor.get_start_date())
                self.collapse_edge_and_remove_ancestor(edge, debug_mode)
                one_to_one_number += 1
                debug_msg_ne(f&#39;    Number of collapsed edges: {one_to_one_number} / {initial_number_one_to_one_edges} &#39;)
        debug_msg(f&#39;    Number of collapsed edges: {one_to_one_number} / {initial_number_one_to_one_edges}&#39;)
        if display_characteristics:
            print(&#39;    Resulting graph characteristics&#39;)
            self.display_characteristics(&#39;       &#39;)

        # ############################
        debug_msg(&#34;  Stage 2: collapsing fusion edges.&#34;)
        initial_number_fusion_edges = \
            len([e for e in self.edges if e.is_fusion()])
        fusion_edges_number = 0
        for time_stamp in time_stamps:
            current_nodes = self.get_nodes_with_time_stamp(time_stamp)
            for node in current_nodes:
                if not node.are_all_ancestor_edges_of_type(Edge.Tag.fused):
                    continue
                if not node.do_all_ancestor_nodes_share_same_date():
                    continue
                # We can proceed with the collapsing of all fusion edges
                node.set_start_date(node.get_ancestors()[0].get_start_date())
                # We need to freeze the list of edges to be dealt with (as opposed
                # to using e.g. &#34;for ancestor_edge in node.get_ancestor_edges()&#34;)
                # because the operator used within the loop possibly modifies
                # that list by adding new edges (that we don&#39;t want to delete)
                # on the fly:
                ancestor_edges = node.get_ancestor_edges().copy()
                for ancestor_edge in ancestor_edges:
                    self.collapse_edge_and_remove_ancestor(ancestor_edge,
                                                           debug_mode)
                number_fusion_edges_left = \
                    len([e for e in self.edges if e.is_fusion()])
                fusion_edges_number = initial_number_fusion_edges \
                    - number_fusion_edges_left
                debug_msg_ne(f&#39;    Number of fusion edges: {fusion_edges_number} / {initial_number_fusion_edges} &#39;)
        debug_msg(f&#39;    Number of fusion edges: {fusion_edges_number} / {initial_number_fusion_edges} &#39;)
        if display_characteristics:
            print(&#39;    Resulting graph characteristics&#39;)
            self.display_characteristics(&#39;       &#39;)

        # #######################
        debug_msg(&#34;  Stage 3: collapsing subdivision edges.&#34;)

        initial_number_fusion_edges = \
            len([e for e in self.edges if e.is_subdivided()])
        number_deleted_edges = 0
        debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
        for time_stamp in time_stamps:
            current_nodes = self.get_nodes_with_time_stamp(time_stamp)
            for node in current_nodes:
                if not node.are_all_descendant_edges_of_type(
                        Edge.Tag.subdivided):
                    continue
                if not node.do_all_descendant_nodes_share_same_date():
                    continue
                ancestor_edges = node.get_ancestor_edges()
                if len(ancestor_edges) &gt; 1:
                    # The proper/clean way of dealing with a subdivided node that
                    # has more thatn one ancestors is not yet established. For
                    # the time being we thus leave such a situation untouched.
                    continue

                # Whether the is no ancestor at all or only one we shall proceed
                # with the &#34;split&#34; of all subdivision edges. For both cases we
                # shall propagate the creation date:
                for descendant_node in node.get_descendants():
                    descendant_node.set_start_date(node.get_start_date())

                if len(ancestor_edges) == 0:
                    # Because we already propagated the creation date of the node
                    # (to its descendants), the set of the descendants capture all
                    # the geometry for the current time stamp. We can thus get
                    # git of the present node and all the sub-division edges
                    # without loss of information (in fact this sub-division was
                    # not a geometrical one but a logical one).
                    for descendant_edge in node.get_descendant_edges().copy():
                        self.disconnect_edge(descendant_edge)
                        self.delete_edge(descendant_edge, True)
                        number_deleted_edges += 1
                        debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)

                    # We can proceed with the removal of the node:
                    self.delete_node(node, debug_mode)

                else:   # This means there is a single ancestor edge
                    # We shall re-label all the sub-divided edges that we deal
                    # with (below) as &#39;modified&#39; so when we build the corresponding
                    # transaction we have a trace that this was a sub-division case
                    # with modification:
                    for descendant_edge in node.get_descendant_edges():
                        descendant_edge.set_modified()
                    ancestor_edge = ancestor_edges[0]
                    if not ancestor_edge.is_modified():
                        print(&#34;All non modified edges should have been collapsed.&#34;)
                        print(&#34;Yet, the following edge is not:&#34;)
                        pprint(vars(ancestor_edge))
                        print(&#34;Exiting&#34;)
                        sys.exit(1)
                    self.split_edge_and_remove_descendant(ancestor_edge,
                                                          debug_mode)
                    number_deleted_edges += 1
                    debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
        debug_msg(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
        if display_characteristics:
            print(&#39;    Resulting graph characteristics&#39;)
            self.display_characteristics(&#39;       &#39;)

        debug_msg(&#34;Simplifying the graph: done.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="py3dtilers.CityTiler.temporal_graph.Graph" href="#py3dtilers.CityTiler.temporal_graph.Graph">Graph</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.CityTiler.temporal_graph.TemporalGraph.extract_time_stamps"><code class="name flex">
<span>def <span class="ident">extract_time_stamps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the ordered (from oldest to most recent) list of time stamps
as extracted from the node's global identifiers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_time_stamps(self):
    &#34;&#34;&#34;
    :return: the ordered (from oldest to most recent) list of time stamps
             as extracted from the node&#39;s global identifiers.
    &#34;&#34;&#34;
    time_stamps_set = set()
    for node in self.nodes:
        time_stamps_set.add(node.get_time_stamp())
    time_stamps = list(time_stamps_set)
    time_stamps.sort()
    return time_stamps</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.TemporalGraph.get_nodes_with_time_stamp"><code class="name flex">
<span>def <span class="ident">get_nodes_with_time_stamp</span></span>(<span>self, time_stamp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodes_with_time_stamp(self, time_stamp):
    if isinstance(time_stamp, str):
        time_stamp = int(time_stamp)
    return [n for n in self.nodes if n.get_time_stamp() == time_stamp]</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.TemporalGraph.reconstruct_connectivity"><code class="name flex">
<span>def <span class="ident">reconstruct_connectivity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_connectivity(self):
    debug_msg(&#34;Reconstructing graph: &#34;)
    debug_msg(&#34;   Loading nodes and edges of files: &#34;)
    # Deserialize the temporal (sub) graphs to constitute the general graph
    for temporal_graph_filename in self.cli_args.temporal_graph:
        with open(temporal_graph_filename, &#39;r&#39;) as temporal_graph_file:
            temporal_graph = json.loads(temporal_graph_file.read(),
                                        cls=GraphMLDecoder)

        current_nodes = temporal_graph[&#39;nodes&#39;]
        # Because the Json GraphML we parse is produced with boost::ptree&#39;s
        # write_json method that is well known for not conforming to Json
        # (integers are serialized as strings i.e. enclosed with double quotes)
        # we need to &#34;fix&#34; things after the Json parser is run
        for node in current_nodes:
            if isinstance(node.id, str):
                node.id = int(node.id)

        current_edges = temporal_graph[&#39;edges&#39;]
        # Edges id must also be type fixed (refer above to current_nodes)
        for edge in current_edges:
            if isinstance(edge.id, str):
                edge.id = int(edge.id)

        # Additionally we need to replace the node indexes (integer) loaded
        # as source and target (with the Json type fix) to their corresponding
        # references (as python objects):
        for edge in current_edges:
            if isinstance(edge.source, str):
                edge.set_ancestor(Graph.find_node_from_id(
                    current_nodes, int(edge.source)))
            if isinstance(edge.target, str):
                edge.set_descendant(Graph.find_node_from_id(
                    current_nodes, int(edge.target)))

        # Eventually we can append the current graph:
        if not self.nodes:
            Graph.__init__(self, current_nodes, current_edges)
        else:
            self.extend_with_subgraph(Graph(current_nodes, current_edges))
        debug_msg(&#34;   &#34; + str(temporal_graph_filename) + &#34;: done.&#34;)
    debug_msg(&#34;  Loading of files: done.&#34;)
    debug_msg(&#34;Graph reconstruction: done.&#34;)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.TemporalGraph.remove_replicate_descendant_edges"><code class="name flex">
<span>def <span class="ident">remove_replicate_descendant_edges</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>When two nodes have multiple adjacent edges (that there exists at least
two edges that are adjacent to same two nodes) then wish to remove the
replicates in order to leave a single edge.
This method considers all the descendant edges of the provided
argument node, looks for replicates and removes them.
:param node: the considered node
:return: the number of edges that were removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_replicate_descendant_edges(self, node):
    &#34;&#34;&#34;
    When two nodes have multiple adjacent edges (that there exists at least
    two edges that are adjacent to same two nodes) then wish to remove the
    replicates in order to leave a single edge.
    This method considers all the descendant edges of the provided
    argument node, looks for replicates and removes them.
    :param node: the considered node
    :return: the number of edges that were removed
    &#34;&#34;&#34;
    number_removed_edges = 0
    seen_node = set()
    for descendant_edge in node.get_descendant_edges():
        descendant = descendant_edge.get_descendant()
        descendant_id = descendant.get_global_id()
        if descendant_id in seen_node:
            # This is a replicate edge that we trash.
            self.disconnect_edge(descendant_edge)
            # Note that we don&#39;t need to inspect for other nodes &#34;knowing&#34;
            # (refering to) that edge because we knew both its endpoints
            # that disconnecting the edge got those nodes informed
            self.delete_edge(descendant_edge, False)
            number_removed_edges += 1
        else:
            seen_node.add(descendant_id)
    return number_removed_edges</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.temporal_graph.TemporalGraph.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>self, display_characteristics=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(self, display_characteristics=False):
    debug_msg(&#34;Simplifying the graph:&#34;)
    # At this point we have lineage information at hand in the form of the
    # reconstructed graph. We still have to simplify that graph in order
    # to re-interpret the available lineages at the level of the objects
    # (the buildings in this application). For example if the building B_1 is
    # present for year Y1, Y2 and Y3 and the land-print (geometry) of the
    # building remains unchanged during those years (same geometry) then
    # we can abstract such a situation by stating (in a 3DTiles temporal
    # framework) that building B_1 has a creation date of Y1 and a deletion
    # date of Y3. In other terms we simplified the sub-graph
    #                 unchanged               unchanged
    #     [B_1, Y1] ------------&gt; [B_1, Y2] -------------&gt; [B_1, Y3]
    # to be reduced to a single node/vertex
    #                           [B_1, Y1-Y3]
    # For more complicated cases (e.g. when the geometry gets modified), the
    # simplified graph will still posses edges that will need to be
    # represented (within the resulting tileset) as (3DTiles) temporal
    # transactions.
    #
    # In the following simplification process note that we iterate over
    # the time stamps in order to apply some graph simplification (empirical)
    # rules. When doing so we start from the past (oldest time stamps) and
    # proceed towards the future (the most recent time stamps). The reason
    # for this past to future time oriented sweeping process (as opposed to
    # random order or from future to past) is to obtain a simplified graph
    # that keeps the most recent building geometries (and removes the oldest
    # nodes i.e. the most ancient building geometries). The assumption behind
    # such time stamp sweeping strategy is that most recent city descriptions
    # are also the most detailed.

    time_stamps = self.extract_time_stamps()

    debug_msg(&#34;  Stage 0: removing duplicate edges.&#34;)
    duplicates = 0
    for time_stamp in time_stamps:
        current_nodes = self.get_nodes_with_time_stamp(time_stamp)
        for node in current_nodes:
            duplicates += self.remove_replicate_descendant_edges(node)
    if duplicates:
        debug_msg(f&#39;    Number of removed duplicates edges: {duplicates}&#39;)
    else:
        debug_msg(&#39;    No duplicates edges found.&#39;)

    # Note that the relative order of application of the following
    # simplification strategies (labeled as stages) does matter. In particular
    #  - collapsing unchanged/re-ided 1 to 1 edges should NOT be realized
    #    prior to collapsing fusion edges, but
    #  - collapsing unchanged/re-ided 1 to 1 edges MUST be realized prior to
    #    collapsing subdivision edges
    # The above constraints on relative order leave a single ordering
    # possibility that is thus used below.

    debug_msg(&#34;  Stage 1: collapsing unchanged/re-ided 1 to 1 edges.&#34;)
    initial_number_one_to_one_edges = \
        len([e for e in self.edges if e.are_adjacent_nodes_one_to_one() and (e.is_unchanged() or e.is_re_ided())])
    one_to_one_number = 0
    to_remove = self.edges.copy()
    for edge in to_remove:
        if not edge.are_adjacent_nodes_one_to_one():
            continue
        if edge.is_unchanged() or edge.is_re_ided():
            ancestor = edge.get_ancestor()
            descendant = edge.get_descendant()
            descendant.set_start_date(ancestor.get_start_date())
            self.collapse_edge_and_remove_ancestor(edge, debug_mode)
            one_to_one_number += 1
            debug_msg_ne(f&#39;    Number of collapsed edges: {one_to_one_number} / {initial_number_one_to_one_edges} &#39;)
    debug_msg(f&#39;    Number of collapsed edges: {one_to_one_number} / {initial_number_one_to_one_edges}&#39;)
    if display_characteristics:
        print(&#39;    Resulting graph characteristics&#39;)
        self.display_characteristics(&#39;       &#39;)

    # ############################
    debug_msg(&#34;  Stage 2: collapsing fusion edges.&#34;)
    initial_number_fusion_edges = \
        len([e for e in self.edges if e.is_fusion()])
    fusion_edges_number = 0
    for time_stamp in time_stamps:
        current_nodes = self.get_nodes_with_time_stamp(time_stamp)
        for node in current_nodes:
            if not node.are_all_ancestor_edges_of_type(Edge.Tag.fused):
                continue
            if not node.do_all_ancestor_nodes_share_same_date():
                continue
            # We can proceed with the collapsing of all fusion edges
            node.set_start_date(node.get_ancestors()[0].get_start_date())
            # We need to freeze the list of edges to be dealt with (as opposed
            # to using e.g. &#34;for ancestor_edge in node.get_ancestor_edges()&#34;)
            # because the operator used within the loop possibly modifies
            # that list by adding new edges (that we don&#39;t want to delete)
            # on the fly:
            ancestor_edges = node.get_ancestor_edges().copy()
            for ancestor_edge in ancestor_edges:
                self.collapse_edge_and_remove_ancestor(ancestor_edge,
                                                       debug_mode)
            number_fusion_edges_left = \
                len([e for e in self.edges if e.is_fusion()])
            fusion_edges_number = initial_number_fusion_edges \
                - number_fusion_edges_left
            debug_msg_ne(f&#39;    Number of fusion edges: {fusion_edges_number} / {initial_number_fusion_edges} &#39;)
    debug_msg(f&#39;    Number of fusion edges: {fusion_edges_number} / {initial_number_fusion_edges} &#39;)
    if display_characteristics:
        print(&#39;    Resulting graph characteristics&#39;)
        self.display_characteristics(&#39;       &#39;)

    # #######################
    debug_msg(&#34;  Stage 3: collapsing subdivision edges.&#34;)

    initial_number_fusion_edges = \
        len([e for e in self.edges if e.is_subdivided()])
    number_deleted_edges = 0
    debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
    for time_stamp in time_stamps:
        current_nodes = self.get_nodes_with_time_stamp(time_stamp)
        for node in current_nodes:
            if not node.are_all_descendant_edges_of_type(
                    Edge.Tag.subdivided):
                continue
            if not node.do_all_descendant_nodes_share_same_date():
                continue
            ancestor_edges = node.get_ancestor_edges()
            if len(ancestor_edges) &gt; 1:
                # The proper/clean way of dealing with a subdivided node that
                # has more thatn one ancestors is not yet established. For
                # the time being we thus leave such a situation untouched.
                continue

            # Whether the is no ancestor at all or only one we shall proceed
            # with the &#34;split&#34; of all subdivision edges. For both cases we
            # shall propagate the creation date:
            for descendant_node in node.get_descendants():
                descendant_node.set_start_date(node.get_start_date())

            if len(ancestor_edges) == 0:
                # Because we already propagated the creation date of the node
                # (to its descendants), the set of the descendants capture all
                # the geometry for the current time stamp. We can thus get
                # git of the present node and all the sub-division edges
                # without loss of information (in fact this sub-division was
                # not a geometrical one but a logical one).
                for descendant_edge in node.get_descendant_edges().copy():
                    self.disconnect_edge(descendant_edge)
                    self.delete_edge(descendant_edge, True)
                    number_deleted_edges += 1
                    debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)

                # We can proceed with the removal of the node:
                self.delete_node(node, debug_mode)

            else:   # This means there is a single ancestor edge
                # We shall re-label all the sub-divided edges that we deal
                # with (below) as &#39;modified&#39; so when we build the corresponding
                # transaction we have a trace that this was a sub-division case
                # with modification:
                for descendant_edge in node.get_descendant_edges():
                    descendant_edge.set_modified()
                ancestor_edge = ancestor_edges[0]
                if not ancestor_edge.is_modified():
                    print(&#34;All non modified edges should have been collapsed.&#34;)
                    print(&#34;Yet, the following edge is not:&#34;)
                    pprint(vars(ancestor_edge))
                    print(&#34;Exiting&#34;)
                    sys.exit(1)
                self.split_edge_and_remove_descendant(ancestor_edge,
                                                      debug_mode)
                number_deleted_edges += 1
                debug_msg_ne(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
    debug_msg(f&#39;   Deleted subdivision edges {number_deleted_edges} / {initial_number_fusion_edges}&#39;)
    if display_characteristics:
        print(&#39;    Resulting graph characteristics&#39;)
        self.display_characteristics(&#39;       &#39;)

    debug_msg(&#34;Simplifying the graph: done.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="py3dtilers.CityTiler.temporal_graph.Graph" href="#py3dtilers.CityTiler.temporal_graph.Graph">Graph</a></b></code>:
<ul class="hlist">
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.collapse_edge_and_remove_ancestor" href="#py3dtilers.CityTiler.temporal_graph.Graph.collapse_edge_and_remove_ancestor">collapse_edge_and_remove_ancestor</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.delete_edge" href="#py3dtilers.CityTiler.temporal_graph.Graph.delete_edge">delete_edge</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.delete_node" href="#py3dtilers.CityTiler.temporal_graph.Graph.delete_node">delete_node</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.disconnect_edge" href="#py3dtilers.CityTiler.temporal_graph.Graph.disconnect_edge">disconnect_edge</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_global_id" href="#py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_global_id">find_node_from_global_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_id" href="#py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_id">find_node_from_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.split_edge_and_remove_descendant" href="#py3dtilers.CityTiler.temporal_graph.Graph.split_edge_and_remove_descendant">split_edge_and_remove_descendant</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="py3dtilers.CityTiler" href="index.html">py3dtilers.CityTiler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="py3dtilers.CityTiler.temporal_graph.Edge" href="#py3dtilers.CityTiler.temporal_graph.Edge">Edge</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.Tag" href="#py3dtilers.CityTiler.temporal_graph.Edge.Tag">Tag</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.append_tag" href="#py3dtilers.CityTiler.temporal_graph.Edge.append_tag">append_tag</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.are_adjacent_nodes_one_to_one" href="#py3dtilers.CityTiler.temporal_graph.Edge.are_adjacent_nodes_one_to_one">are_adjacent_nodes_one_to_one</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.get_ancestor" href="#py3dtilers.CityTiler.temporal_graph.Edge.get_ancestor">get_ancestor</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.get_descendant" href="#py3dtilers.CityTiler.temporal_graph.Edge.get_descendant">get_descendant</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.is_fusion" href="#py3dtilers.CityTiler.temporal_graph.Edge.is_fusion">is_fusion</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.is_modified" href="#py3dtilers.CityTiler.temporal_graph.Edge.is_modified">is_modified</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.is_of_type" href="#py3dtilers.CityTiler.temporal_graph.Edge.is_of_type">is_of_type</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.is_re_ided" href="#py3dtilers.CityTiler.temporal_graph.Edge.is_re_ided">is_re_ided</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.is_replace" href="#py3dtilers.CityTiler.temporal_graph.Edge.is_replace">is_replace</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.is_subdivided" href="#py3dtilers.CityTiler.temporal_graph.Edge.is_subdivided">is_subdivided</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.is_tag_in_tags" href="#py3dtilers.CityTiler.temporal_graph.Edge.is_tag_in_tags">is_tag_in_tags</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.is_unchanged" href="#py3dtilers.CityTiler.temporal_graph.Edge.is_unchanged">is_unchanged</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.set_ancestor" href="#py3dtilers.CityTiler.temporal_graph.Edge.set_ancestor">set_ancestor</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.set_descendant" href="#py3dtilers.CityTiler.temporal_graph.Edge.set_descendant">set_descendant</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.set_modified" href="#py3dtilers.CityTiler.temporal_graph.Edge.set_modified">set_modified</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Edge.set_tag_from_string" href="#py3dtilers.CityTiler.temporal_graph.Edge.set_tag_from_string">set_tag_from_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.CityTiler.temporal_graph.Graph" href="#py3dtilers.CityTiler.temporal_graph.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.add_node" href="#py3dtilers.CityTiler.temporal_graph.Graph.add_node">add_node</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.collapse_edge_and_remove_ancestor" href="#py3dtilers.CityTiler.temporal_graph.Graph.collapse_edge_and_remove_ancestor">collapse_edge_and_remove_ancestor</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.delete_edge" href="#py3dtilers.CityTiler.temporal_graph.Graph.delete_edge">delete_edge</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.delete_node" href="#py3dtilers.CityTiler.temporal_graph.Graph.delete_node">delete_node</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.disconnect_edge" href="#py3dtilers.CityTiler.temporal_graph.Graph.disconnect_edge">disconnect_edge</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.display_characteristics" href="#py3dtilers.CityTiler.temporal_graph.Graph.display_characteristics">display_characteristics</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.extend_with_subgraph" href="#py3dtilers.CityTiler.temporal_graph.Graph.extend_with_subgraph">extend_with_subgraph</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_global_id" href="#py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_global_id">find_node_from_global_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_id" href="#py3dtilers.CityTiler.temporal_graph.Graph.find_node_from_id">find_node_from_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.print_nodes_and_edges" href="#py3dtilers.CityTiler.temporal_graph.Graph.print_nodes_and_edges">print_nodes_and_edges</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Graph.split_edge_and_remove_descendant" href="#py3dtilers.CityTiler.temporal_graph.Graph.split_edge_and_remove_descendant">split_edge_and_remove_descendant</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.CityTiler.temporal_graph.GraphMLDecoder" href="#py3dtilers.CityTiler.temporal_graph.GraphMLDecoder">GraphMLDecoder</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.CityTiler.temporal_graph.GraphMLDecoder.dict_to_object" href="#py3dtilers.CityTiler.temporal_graph.GraphMLDecoder.dict_to_object">dict_to_object</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.CityTiler.temporal_graph.Node" href="#py3dtilers.CityTiler.temporal_graph.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.Status" href="#py3dtilers.CityTiler.temporal_graph.Node.Status">Status</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.add_ancestor_edge" href="#py3dtilers.CityTiler.temporal_graph.Node.add_ancestor_edge">add_ancestor_edge</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.add_ancestor_edges" href="#py3dtilers.CityTiler.temporal_graph.Node.add_ancestor_edges">add_ancestor_edges</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.add_descendant_edge" href="#py3dtilers.CityTiler.temporal_graph.Node.add_descendant_edge">add_descendant_edge</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.add_descendant_edges" href="#py3dtilers.CityTiler.temporal_graph.Node.add_descendant_edges">add_descendant_edges</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.are_all_ancestor_edges_of_type" href="#py3dtilers.CityTiler.temporal_graph.Node.are_all_ancestor_edges_of_type">are_all_ancestor_edges_of_type</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.are_all_descendant_edges_of_type" href="#py3dtilers.CityTiler.temporal_graph.Node.are_all_descendant_edges_of_type">are_all_descendant_edges_of_type</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.assert_status_coherence" href="#py3dtilers.CityTiler.temporal_graph.Node.assert_status_coherence">assert_status_coherence</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.disconnect_adjacent_edges" href="#py3dtilers.CityTiler.temporal_graph.Node.disconnect_adjacent_edges">disconnect_adjacent_edges</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.do_all_ancestor_nodes_share_same_date" href="#py3dtilers.CityTiler.temporal_graph.Node.do_all_ancestor_nodes_share_same_date">do_all_ancestor_nodes_share_same_date</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.do_all_descendant_nodes_share_same_date" href="#py3dtilers.CityTiler.temporal_graph.Node.do_all_descendant_nodes_share_same_date">do_all_descendant_nodes_share_same_date</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_ancestor_edges" href="#py3dtilers.CityTiler.temporal_graph.Node.get_ancestor_edges">get_ancestor_edges</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_ancestors" href="#py3dtilers.CityTiler.temporal_graph.Node.get_ancestors">get_ancestors</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_descendant_edges" href="#py3dtilers.CityTiler.temporal_graph.Node.get_descendant_edges">get_descendant_edges</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_descendants" href="#py3dtilers.CityTiler.temporal_graph.Node.get_descendants">get_descendants</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_end_date" href="#py3dtilers.CityTiler.temporal_graph.Node.get_end_date">get_end_date</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_global_id" href="#py3dtilers.CityTiler.temporal_graph.Node.get_global_id">get_global_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_local_id" href="#py3dtilers.CityTiler.temporal_graph.Node.get_local_id">get_local_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_start_date" href="#py3dtilers.CityTiler.temporal_graph.Node.get_start_date">get_start_date</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.get_time_stamp" href="#py3dtilers.CityTiler.temporal_graph.Node.get_time_stamp">get_time_stamp</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.is_end" href="#py3dtilers.CityTiler.temporal_graph.Node.is_end">is_end</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.is_hapax" href="#py3dtilers.CityTiler.temporal_graph.Node.is_hapax">is_hapax</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.is_link" href="#py3dtilers.CityTiler.temporal_graph.Node.is_link">is_link</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.is_start" href="#py3dtilers.CityTiler.temporal_graph.Node.is_start">is_start</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.is_unknown" href="#py3dtilers.CityTiler.temporal_graph.Node.is_unknown">is_unknown</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.reset_descendant_edges" href="#py3dtilers.CityTiler.temporal_graph.Node.reset_descendant_edges">reset_descendant_edges</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_creation_date_if_earlier" href="#py3dtilers.CityTiler.temporal_graph.Node.set_creation_date_if_earlier">set_creation_date_if_earlier</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_creation_date_recursive" href="#py3dtilers.CityTiler.temporal_graph.Node.set_creation_date_recursive">set_creation_date_recursive</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_deletion_date_if_later" href="#py3dtilers.CityTiler.temporal_graph.Node.set_deletion_date_if_later">set_deletion_date_if_later</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_end" href="#py3dtilers.CityTiler.temporal_graph.Node.set_end">set_end</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_end_date" href="#py3dtilers.CityTiler.temporal_graph.Node.set_end_date">set_end_date</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_hapax" href="#py3dtilers.CityTiler.temporal_graph.Node.set_hapax">set_hapax</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_link" href="#py3dtilers.CityTiler.temporal_graph.Node.set_link">set_link</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_start" href="#py3dtilers.CityTiler.temporal_graph.Node.set_start">set_start</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.Node.set_start_date" href="#py3dtilers.CityTiler.temporal_graph.Node.set_start_date">set_start_date</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.CityTiler.temporal_graph.TemporalGraph" href="#py3dtilers.CityTiler.temporal_graph.TemporalGraph">TemporalGraph</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.CityTiler.temporal_graph.TemporalGraph.extract_time_stamps" href="#py3dtilers.CityTiler.temporal_graph.TemporalGraph.extract_time_stamps">extract_time_stamps</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.TemporalGraph.get_nodes_with_time_stamp" href="#py3dtilers.CityTiler.temporal_graph.TemporalGraph.get_nodes_with_time_stamp">get_nodes_with_time_stamp</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.TemporalGraph.reconstruct_connectivity" href="#py3dtilers.CityTiler.temporal_graph.TemporalGraph.reconstruct_connectivity">reconstruct_connectivity</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.TemporalGraph.remove_replicate_descendant_edges" href="#py3dtilers.CityTiler.temporal_graph.TemporalGraph.remove_replicate_descendant_edges">remove_replicate_descendant_edges</a></code></li>
<li><code><a title="py3dtilers.CityTiler.temporal_graph.TemporalGraph.simplify" href="#py3dtilers.CityTiler.temporal_graph.TemporalGraph.simplify">simplify</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>